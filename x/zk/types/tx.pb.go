// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: persona_chain/zk/v1/tx.proto

package types

import (
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgSubmitProof represents a message to submit a ZK proof
type MsgSubmitProof struct {
	Creator      string   `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	CircuitId    string   `protobuf:"bytes,2,opt,name=circuit_id,json=circuitId,proto3" json:"circuit_id,omitempty"`
	Proof        string   `protobuf:"bytes,3,opt,name=proof,proto3" json:"proof,omitempty"`
	PublicInputs []string `protobuf:"bytes,4,rep,name=public_inputs,json=publicInputs,proto3" json:"public_inputs,omitempty"`
	Metadata     string   `protobuf:"bytes,5,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *MsgSubmitProof) Reset()         { *m = MsgSubmitProof{} }
func (m *MsgSubmitProof) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitProof) ProtoMessage()    {}

// MsgSubmitProofResponse defines the response type
type MsgSubmitProofResponse struct {
}

func (m *MsgSubmitProofResponse) Reset()         { *m = MsgSubmitProofResponse{} }
func (m *MsgSubmitProofResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitProofResponse) ProtoMessage()    {}

// Marshal implementations
func (m *MsgSubmitProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PublicInputs) > 0 {
		for iNdEx := len(m.PublicInputs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PublicInputs[iNdEx])
			copy(dAtA[i:], m.PublicInputs[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.PublicInputs[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Proof) > 0 {
		i -= len(m.Proof)
		copy(dAtA[i:], m.Proof)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Proof)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CircuitId) > 0 {
		i -= len(m.CircuitId)
		copy(dAtA[i:], m.CircuitId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CircuitId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CircuitId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Proof)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.PublicInputs) > 0 {
		for _, s := range m.PublicInputs {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}

// Unmarshal implementations (minimal)
func (m *MsgSubmitProof) Unmarshal(dAtA []byte) error {
	return nil
}