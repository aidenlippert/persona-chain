// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: persona_chain/vc/v1/tx.proto

package types

import (
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgIssueVc represents a message to issue a verifiable credential
type MsgIssueVc struct {
	Issuer           string `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
	Id               string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	IssuerDid        string `protobuf:"bytes,3,opt,name=issuer_did,json=issuerDid,proto3" json:"issuer_did,omitempty"`
	SubjectDid       string `protobuf:"bytes,4,opt,name=subject_did,json=subjectDid,proto3" json:"subject_did,omitempty"`
	CredentialSchema string `protobuf:"bytes,5,opt,name=credential_schema,json=credentialSchema,proto3" json:"credential_schema,omitempty"`
	CredentialData   string `protobuf:"bytes,6,opt,name=credential_data,json=credentialData,proto3" json:"credential_data,omitempty"`
	Proof            string `protobuf:"bytes,7,opt,name=proof,proto3" json:"proof,omitempty"`
	ExpiresAt        int64  `protobuf:"varint,8,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
}

func (m *MsgIssueVc) Reset()         { *m = MsgIssueVc{} }
func (m *MsgIssueVc) String() string { return proto.CompactTextString(m) }
func (*MsgIssueVc) ProtoMessage()    {}

// MsgIssueVcResponse defines the response type
type MsgIssueVcResponse struct {
}

func (m *MsgIssueVcResponse) Reset()         { *m = MsgIssueVcResponse{} }
func (m *MsgIssueVcResponse) String() string { return proto.CompactTextString(m) }
func (*MsgIssueVcResponse) ProtoMessage()    {}

// MsgRevokeVc represents a message to revoke a verifiable credential
type MsgRevokeVc struct {
	Creator      string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	CredentialId string `protobuf:"bytes,2,opt,name=credential_id,json=credentialId,proto3" json:"credential_id,omitempty"`
	Reason       string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *MsgRevokeVc) Reset()         { *m = MsgRevokeVc{} }
func (m *MsgRevokeVc) String() string { return proto.CompactTextString(m) }
func (*MsgRevokeVc) ProtoMessage()    {}

// MsgRevokeVcResponse defines the response type
type MsgRevokeVcResponse struct {
}

func (m *MsgRevokeVcResponse) Reset()         { *m = MsgRevokeVcResponse{} }
func (m *MsgRevokeVcResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRevokeVcResponse) ProtoMessage()    {}

// Marshal implementations
func (m *MsgIssueVc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgIssueVc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiresAt != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ExpiresAt))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Proof) > 0 {
		i -= len(m.Proof)
		copy(dAtA[i:], m.Proof)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Proof)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CredentialData) > 0 {
		i -= len(m.CredentialData)
		copy(dAtA[i:], m.CredentialData)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CredentialData)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CredentialSchema) > 0 {
		i -= len(m.CredentialSchema)
		copy(dAtA[i:], m.CredentialSchema)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CredentialSchema)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SubjectDid) > 0 {
		i -= len(m.SubjectDid)
		copy(dAtA[i:], m.SubjectDid)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SubjectDid)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IssuerDid) > 0 {
		i -= len(m.IssuerDid)
		copy(dAtA[i:], m.IssuerDid)
		i = encodeVarintTx(dAtA, i, uint64(len(m.IssuerDid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgIssueVc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.IssuerDid)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SubjectDid)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CredentialSchema)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CredentialData)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Proof)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovTx(uint64(m.ExpiresAt))
	}
	return n
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}

// Unmarshal implementations (minimal)
func (m *MsgIssueVc) Unmarshal(dAtA []byte) error {
	return nil
}