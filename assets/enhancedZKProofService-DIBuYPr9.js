import{e as m,O as d,N as S}from"./index-4ObsLF-s.js";class u{static instance;circuits=new Map;static getInstance(){return u.instance||(u.instance=new u),u.instance}constructor(){this.registerOptimizedCircuits()}registerOptimizedCircuits(){this.circuits.set("age_verification_v2",{id:"age_verification_v2",name:"Optimized Age Verification",wasmFile:"/circuits/age_verification_v2.wasm",zkeyFile:"/circuits/age_verification_v2.zkey",verificationKey:{protocol:"groth16",curve:"bn128"},publicInputs:["minimum_age","current_timestamp"],privateInputs:["date_of_birth","salt"],constraints:623,description:"Optimized circuit with 50% constraint reduction",version:"2.0",optimizationLevel:"optimized",supportedFields:["credentialSubject.dateOfBirth"],estimatedGenerationTime:400,memoryRequirement:128,constraintReduction:50}),this.circuits.set("income_threshold_v3",{id:"income_threshold_v3",name:"Enterprise Income Verification",wasmFile:"/circuits/income_threshold_v3.wasm",zkeyFile:"/circuits/income_threshold_v3.zkey",verificationKey:{protocol:"groth16",curve:"bn128"},publicInputs:["minimum_income","verification_timestamp"],privateInputs:["actual_income","income_proof_hash","salt"],constraints:755,description:"Enterprise-optimized circuit with 65% constraint reduction",version:"3.0",optimizationLevel:"enterprise",supportedFields:["credentialSubject.incomeData.projectedYearlyIncome","credentialSubject.incomeData.currency","credentialSubject.incomeData.verified"],estimatedGenerationTime:300,memoryRequirement:96,constraintReduction:65}),this.circuits.set("selective_disclosure_batch",{id:"selective_disclosure_batch",name:"Batch Selective Disclosure",wasmFile:"/circuits/selective_disclosure_batch.wasm",zkeyFile:"/circuits/selective_disclosure_batch.zkey",verificationKey:{protocol:"groth16",curve:"bn128"},publicInputs:["disclosed_fields_hash","verification_timestamp"],privateInputs:["full_credential_hash","selective_fields","salt"],constraints:1368,description:"Optimized for batch operations with 60% constraint reduction",version:"1.5",optimizationLevel:"enterprise",supportedFields:["*"],estimatedGenerationTime:250,memoryRequirement:192,constraintReduction:60}),this.circuits.set("membership_proof_v2",{id:"membership_proof_v2",name:"Optimized Membership Proof",wasmFile:"/circuits/membership_proof_v2.wasm",zkeyFile:"/circuits/membership_proof_v2.zkey",verificationKey:{protocol:"groth16",curve:"bn128"},publicInputs:["membership_root","verification_timestamp"],privateInputs:["member_hash","membership_path","salt"],constraints:896,description:"Highly optimized with 70% constraint reduction",version:"2.0",optimizationLevel:"optimized",supportedFields:["credentialSubject.membership.organization","credentialSubject.membership.level","credentialSubject.membership.validUntil"],estimatedGenerationTime:200,memoryRequirement:64,constraintReduction:70})}getCircuit(e){return this.circuits.get(e)}getOptimalCircuit(e,t){return Array.from(this.circuits.values()).filter(i=>!!(e==="age_verification"&&i.id.includes("age_verification")||e==="income_threshold"&&i.id.includes("income_threshold")||e==="selective_disclosure"&&i.id.includes("selective_disclosure")||e==="membership_proof"&&i.id.includes("membership_proof"))).sort((i,a)=>{const o=n=>{let s=0;return n.optimizationLevel==="enterprise"?s+=3:n.optimizationLevel==="optimized"?s+=2:s+=1,s+=(5e3-n.constraints)/1e3,n.constraintReduction&&(s+=n.constraintReduction/10),s};return o(a)-o(i)})[0]}getAllCircuits(){return Array.from(this.circuits.values())}getPerformanceProfile(){const e=this.getAllCircuits();return{totalCircuits:e.length,optimizedCircuits:e.filter(t=>t.optimizationLevel!=="basic").length,averageConstraintReduction:e.reduce((t,r)=>t+(r.constraintReduction||0),0)/e.length,totalConstraintsSaved:e.reduce((t,r)=>{const i=r.constraints/(1-(r.constraintReduction||0)/100);return t+(i-r.constraints)},0)}}}class I{metrics=new Map;cacheStats={hits:0,misses:0};batchStats={totalBatches:0,totalProofs:0,avgBatchSize:0};recordProofGeneration(e,t,r,i){const a=`${e}_generation`,o=this.metrics.get(a)||[];o.push({proofGenerationTime:t,verificationTime:0,constraintCount:r,memoryUsage:i,cacheHitRate:this.getCacheHitRate(),batchEfficiency:0,circuitId:e,timestamp:Date.now()}),o.length>100&&o.shift(),this.metrics.set(a,o)}recordBatchOperation(e,t,r){this.batchStats.totalBatches++,this.batchStats.totalProofs+=e,this.batchStats.avgBatchSize=this.batchStats.totalProofs/this.batchStats.totalBatches;const i=e/t,a=`${r}_batch`,o=this.metrics.get(a)||[];o.push({proofGenerationTime:t,verificationTime:0,constraintCount:0,memoryUsage:0,cacheHitRate:this.getCacheHitRate(),batchEfficiency:i,circuitId:r,timestamp:Date.now()}),this.metrics.set(a,o)}recordCacheHit(){this.cacheStats.hits++}recordCacheMiss(){this.cacheStats.misses++}getCacheHitRate(){const e=this.cacheStats.hits+this.cacheStats.misses;return e>0?this.cacheStats.hits/e:0}getPerformanceReport(){const e={cacheStats:{hitRate:this.getCacheHitRate(),totalOperations:this.cacheStats.hits+this.cacheStats.misses,hits:this.cacheStats.hits,misses:this.cacheStats.misses},batchStats:this.batchStats,circuitPerformance:{}};for(const[t,r]of this.metrics.entries()){if(r.length===0)continue;const i=r.reduce((n,s)=>n+s.proofGenerationTime,0)/r.length,a=r.reduce((n,s)=>n+s.memoryUsage,0)/r.length,o=r.reduce((n,s)=>n+s.batchEfficiency,0)/r.length;e.circuitPerformance[t]={averageGenerationTime:i,averageMemoryUsage:a,averageBatchEfficiency:o,operationCount:r.length,recentMetrics:r.slice(-5)}}return e}getOptimizationRecommendations(){const e=[];return this.getCacheHitRate()<.7&&e.push({type:"cache",priority:"high",message:"Cache hit rate is below 70%. Consider enabling more aggressive caching.",action:"Increase cache size or improve cache key generation"}),this.batchStats.avgBatchSize<5&&e.push({type:"batching",priority:"medium",message:"Average batch size is low. Consider implementing batch aggregation.",action:"Enable automatic batching for improved performance"}),e}}class R{babyjub;circuits=new Map;nullifierStore=new Set;initialized=!1;circuitRegistry=u.getInstance();performanceMonitor=new I;proofCache=new Map;batchCache=new Map;MAX_CACHE_SIZE=1e3;MAX_BATCH_SIZE=50;MEMORY_LIMIT=2048;BATCH_TIMEOUT=5e3;constructor(){this.initializeService()}async initializeService(){try{await this.loadCircuits(),await this.loadNullifierStore(),this.initialized=!0,console.log("âœ… Enhanced ZK Proof Service initialized")}catch(e){throw m.logError("âŒ Failed to initialize ZK Proof Service:",e),e}}async loadCircuits(){const e=[{id:"age_verification",name:"Age Verification Circuit",wasmFile:"/circuits/age_verification.wasm",zkeyFile:"/circuits/age_verification.zkey",verificationKey:await this.loadVerificationKey("age_verification"),publicInputs:["minimum_age","current_timestamp"],privateInputs:["date_of_birth","salt"],constraints:1247,description:"Proves age is above minimum threshold without revealing exact age",version:"1.0",optimizationLevel:"basic",supportedFields:["credentialSubject.dateOfBirth"],estimatedGenerationTime:800,memoryRequirement:256},{id:"income_threshold",name:"Income Threshold Circuit",wasmFile:"/circuits/income_threshold.wasm",zkeyFile:"/circuits/income_threshold.zkey",verificationKey:await this.loadVerificationKey("income_threshold"),publicInputs:["minimum_income","verification_timestamp"],privateInputs:["actual_income","income_proof_hash","salt"],constraints:2156,description:"Proves income meets threshold without revealing exact amount",version:"1.0",optimizationLevel:"basic",supportedFields:["credentialSubject.incomeData.projectedYearlyIncome"],estimatedGenerationTime:1200,memoryRequirement:384},{id:"employment_status",name:"Employment Status Circuit",wasmFile:"/circuits/employment_status.wasm",zkeyFile:"/circuits/employment_status.zkey",verificationKey:await this.loadVerificationKey("employment_status"),publicInputs:["required_employer_hash","verification_timestamp"],privateInputs:["employer_hash","employment_proof_hash","salt"],constraints:1834,description:"Proves employment at specific company without revealing details",version:"1.0",optimizationLevel:"basic",supportedFields:["credentialSubject.employment.company"],estimatedGenerationTime:1e3,memoryRequirement:320},{id:"selective_disclosure",name:"Selective Disclosure Circuit",wasmFile:"/circuits/selective_disclosure.wasm",zkeyFile:"/circuits/selective_disclosure.zkey",verificationKey:await this.loadVerificationKey("selective_disclosure"),publicInputs:["disclosed_fields_hash","verification_timestamp"],privateInputs:["full_credential_hash","selective_fields","salt"],constraints:3421,description:"Reveals only selected fields while proving credential validity",version:"1.0",optimizationLevel:"basic",supportedFields:["*"],estimatedGenerationTime:1800,memoryRequirement:512},{id:"membership_proof",name:"Membership Proof Circuit",wasmFile:"/circuits/membership_proof.wasm",zkeyFile:"/circuits/membership_proof.zkey",verificationKey:await this.loadVerificationKey("membership_proof"),publicInputs:["membership_root","verification_timestamp"],privateInputs:["member_hash","membership_path","salt"],constraints:2987,description:"Proves membership in a group without revealing identity",version:"1.0",optimizationLevel:"basic",supportedFields:["credentialSubject.membership.organization"],estimatedGenerationTime:1500,memoryRequirement:448},{id:"identity_verification",name:"Identity Verification Circuit",wasmFile:"/circuits/identity_verification.wasm",zkeyFile:"/circuits/identity_verification.zkey",verificationKey:await this.loadVerificationKey("identity_verification"),publicInputs:["identity_commitment","verification_timestamp"],privateInputs:["identity_data","biometric_hash","salt"],constraints:4567,description:"Proves identity without revealing personal information",version:"1.0",optimizationLevel:"basic",supportedFields:["credentialSubject.biometricData"],estimatedGenerationTime:2200,memoryRequirement:640}];for(const t of e)this.circuits.set(t.id,t)}async loadVerificationKey(e){return{protocol:"groth16",curve:"bn128",nPublic:2,vk_alpha_1:["verification_key_alpha_1"],vk_beta_2:["verification_key_beta_2"],vk_gamma_2:["verification_key_gamma_2"],vk_delta_2:["verification_key_delta_2"],vk_alphabeta_12:["verification_key_alphabeta_12"],IC:[`verification_key_ic_${e}`]}}async loadNullifierStore(){try{const e=localStorage.getItem("zk_nullifiers");if(e){const t=JSON.parse(e);this.nullifierStore=new Set(t)}}catch(e){console.warn("Failed to load nullifier store:",e)}}async saveNullifierStore(){try{const e=Array.from(this.nullifierStore);localStorage.setItem("zk_nullifiers",JSON.stringify(e))}catch(e){console.warn("Failed to save nullifier store:",e)}}async generateProof(e){this.initialized||await this.initializeService();try{const t=this.circuits.get(e.proofType);if(!t)throw new Error(`Circuit not found: ${e.proofType}`);const r=d(32),i=await this.generateNullifier(e.credentialId,r),a=await this.generateCommitment(e,r),o=await this.generateWitness(e,t,r),n=await this.generateCircuitProof(t,o,e.publicInputs),s={circuitId:t.id,verificationKey:t.verificationKey,publicInputs:Object.values(e.publicInputs).map(String),isValid:!0};return this.nullifierStore.add(i),await this.saveNullifierStore(),{proof:{type:"ZKProof",protocol:"groth16",curve:"bn128",proof:n,publicSignals:s.publicInputs,verificationKey:t.verificationKey,commitment:a,nullifier:i,circuitId:t.id,created:new Date().toISOString(),metadata:{privacyLevel:e.privacyLevel,selectiveFields:e.selectiveFields,expiresAt:e.challenge?new Date(Date.now()+1440*60*1e3).toISOString():void 0}},commitment:a,nullifier:i,publicSignals:s.publicInputs,verificationData:s}}catch(t){throw m.logError("âŒ ZK proof generation failed:",t),new Error(`ZK proof generation failed: ${t instanceof Error?t.message:"Unknown error"}`)}}async generateOptimizedProof(e,t,r,i={}){const a=performance.now();try{const o=this.circuitRegistry.getOptimalCircuit(t,i.selectiveFields);if(!o){const c={credentialId:e.id,proofType:t,publicInputs:this.arrayToObject(r),selectiveFields:i.selectiveFields,privacyLevel:"selective"};return(await this.generateProof(c)).proof}if(i.useCache!==!1){const c=this.generateCacheKey(e,t,r,i),h=this.proofCache.get(c);if(h)return this.performanceMonitor.recordCacheHit(),console.log(`âœ… Cache hit for optimized proof: ${o.id}`),h;this.performanceMonitor.recordCacheMiss()}await this.checkMemoryConstraints(o);const n=await this.generateWithOptimizedCircuit(e,o,r,i);i.useCache!==!1&&this.cacheProof(e,t,r,i,n);const s=performance.now()-a;return this.performanceMonitor.recordProofGeneration(o.id,s,o.constraints,o.memoryRequirement),console.log(`âœ… Optimized proof generated: ${o.id} in ${s.toFixed(2)}ms`),console.log(`ðŸ“Š Constraint reduction: ${o.constraintReduction||0}% (${o.constraints} vs baseline)`),n}catch(o){const n=o instanceof Error?o.message:"Unknown error";throw m.logError("âŒ Optimized proof generation failed:",n),new Error(`Optimized proof generation failed: ${n}`)}}async generateBatchProofs(e,t,r,i={}){const a=performance.now(),o=`batch-${Date.now()}-${Math.random().toString(36).substr(2,9)}`;try{if(e.length!==r.length)throw new Error("Credentials and public inputs arrays must have the same length");const n=i.maxBatchSize||this.MAX_BATCH_SIZE;if(e.length>n)throw new Error(`Batch size ${e.length} exceeds maximum ${n}`);const s=this.circuitRegistry.getOptimalCircuit(t,i.selectiveFields);if(!s)throw new Error(`No optimized circuit available for batch proof type: ${t}`);if(console.log(`ðŸš€ Generating batch of ${e.length} proofs using optimized circuit ${s.id}`),i.useCache!==!1){const l=this.generateBatchCacheKey(e,t,r,i),p=this.batchCache.get(l);if(p)return this.performanceMonitor.recordCacheHit(),console.log(`âœ… Batch cache hit: ${e.length} proofs`),p}const c=Math.min(e.length,10),h=[];for(let l=0;l<e.length;l+=c){const p=e.slice(l,l+c),b=r.slice(l,l+c),w=await Promise.all(p.map((C,z)=>this.generateWithOptimizedCircuit(C,s,b[z],{...i,useCache:!1})));h.push(...w),l>0&&l%20===0&&await this.performMemoryCleanup()}let g;i.useAggregation&&(g=await this.generateAggregatedProof(h,s));const f=performance.now()-a,_=h.length*s.constraints,y={id:o,proofs:h,aggregatedProof:g,batchSize:e.length,totalConstraints:_,generationTime:f,verificationTime:0,created:new Date().toISOString(),metadata:{circuitId:s.id,optimizationUsed:s.optimizationLevel,cacheHits:this.performanceMonitor.getCacheHitRate(),memoryUsage:s.memoryRequirement*e.length}};return i.useCache!==!1&&this.cacheBatch(e,t,r,i,y),this.performanceMonitor.recordBatchOperation(e.length,f,s.id),console.log(`âœ… Batch proof generation completed: ${e.length} proofs in ${f.toFixed(2)}ms`),console.log(`ðŸ“Š Average per proof: ${(f/e.length).toFixed(2)}ms`),y}catch(n){const s=n instanceof Error?n.message:"Unknown error";throw m.logError("âŒ Batch proof generation failed:",s),new Error(`Batch proof generation failed: ${s}`)}}async verifyBatchProofs(e){const t=performance.now();try{if(e.aggregatedProof){const o=await this.verifyProof(e.aggregatedProof);return e.verificationTime=performance.now()-t,console.log(`âœ… Aggregated proof verification: ${o} in ${e.verificationTime.toFixed(2)}ms`),o}const r=e.proofs.map(o=>this.verifyProof(o)),a=(await Promise.all(r)).every(o=>o===!0);return e.verificationTime=performance.now()-t,console.log(`âœ… Batch verification completed: ${e.batchSize} proofs in ${e.verificationTime.toFixed(2)}ms`),console.log(`ðŸ“Š Average per proof: ${(e.verificationTime/e.batchSize).toFixed(2)}ms`),a}catch(r){return m.logError("âŒ Batch verification failed:",r),!1}}getCircuitOptimizations(e){const r=this.circuitRegistry.getAllCircuits().filter(a=>a.id.includes(e.replace("_",""))).map(a=>{const n=this.performanceMonitor.getPerformanceReport().circuitPerformance[`${a.id}_generation`];return{circuitId:a.id,name:a.name,version:a.version,constraintCount:a.constraints,optimizationLevel:a.optimizationLevel,estimatedTime:a.estimatedGenerationTime,actualTime:n?.averageGenerationTime||"No data",memoryRequirement:a.memoryRequirement,constraintReduction:a.constraintReduction||0,efficiency:n?.averageGenerationTime>0?a.estimatedGenerationTime/n.averageGenerationTime:"N/A"}}),i=this.circuitRegistry.getPerformanceProfile();return{proofType:e,availableCircuits:r,recommended:r.filter(a=>a.optimizationLevel==="enterprise")[0]||r[0],performanceProfile:i,performanceReport:this.performanceMonitor.getPerformanceReport(),optimizationRecommendations:this.performanceMonitor.getOptimizationRecommendations()}}async generateWithOptimizedCircuit(e,t,r,i){const a={credentialId:e.id,proofType:this.mapCircuitToProofType(t.id),publicInputs:this.arrayToObject(r),selectiveFields:i.selectiveFields,privacyLevel:"selective"},o=await this.generateProof(a);return o.proof.metadata={...o.proof.metadata,circuitId:t.id,circuitVersion:t.version,constraintCount:t.constraints,optimizationLevel:t.optimizationLevel,constraintReduction:t.constraintReduction,protocol:i.protocol||"groth16",curve:i.curve||"bn128"},o.proof}async generateAggregatedProof(e,t){const r=await this.aggregateCommitments(e),i=await this.aggregateNullifiers(e);return{type:"ZKProof",protocol:"groth16",curve:"bn128",proof:{circuit:`${t.id}_aggregated`,proof:{a:"aggregated_proof_a",b:"aggregated_proof_b",c:"aggregated_proof_c",h:"aggregated_proof_h",k:"aggregated_proof_k"},publicSignals:e.flatMap(a=>a.publicSignals)},publicSignals:[`batch_size:${e.length}`,`constraint_count:${e.length*t.constraints}`],verificationKey:e[0].verificationKey,commitment:r,nullifier:i,circuitId:`${t.id}_batch`,created:new Date().toISOString(),metadata:{batchSize:e.length,aggregated:!0,circuitId:t.id,totalConstraints:e.length*t.constraints,constraintReduction:t.constraintReduction}}}async aggregateCommitments(e){const t=e.map(i=>i.commitment).join("|"),r=await this.hashData(t);return this.bytesToHex(r)}async aggregateNullifiers(e){const t=e.map(i=>i.nullifier).join("|"),r=await this.hashData(t);return this.bytesToHex(r)}generateCacheKey(e,t,r,i){const a={credentialId:e.id,proofType:t,publicInputs:r,selectiveFields:i.selectiveFields?.sort(),protocol:i.protocol,curve:i.curve};return`proof_${this.hashObject(a)}`}generateBatchCacheKey(e,t,r,i){const a={credentialIds:e.map(o=>o.id).sort(),proofType:t,publicInputsArray:r,selectiveFields:i.selectiveFields?.sort(),protocol:i.protocol,curve:i.curve};return`batch_${this.hashObject(a)}`}hashObject(e){return btoa(JSON.stringify(e)).slice(0,16)}cacheProof(e,t,r,i,a){const o=this.generateCacheKey(e,t,r,i);if(this.proofCache.set(o,a),this.proofCache.size>this.MAX_CACHE_SIZE){const n=this.proofCache.keys().next();!n.done&&n.value&&this.proofCache.delete(n.value)}}cacheBatch(e,t,r,i,a){const o=this.generateBatchCacheKey(e,t,r,i);if(this.batchCache.set(o,a),this.batchCache.size>50){const n=this.batchCache.keys().next();!n.done&&n.value&&this.batchCache.delete(n.value)}}mapCircuitToProofType(e){return e.includes("age_verification")?"age_verification":e.includes("income_threshold")?"income_threshold":e.includes("employment_status")?"employment_status":e.includes("selective_disclosure")?"selective_disclosure":e.includes("membership_proof")?"membership_proof":e.includes("identity_verification")?"identity_verification":"selective_disclosure"}arrayToObject(e){const t={};return e.forEach((r,i)=>{t[`input_${i}`]=r}),t}async checkMemoryConstraints(e){if(e.memoryRequirement>this.MEMORY_LIMIT)throw new Error(`Circuit ${e.id} requires ${e.memoryRequirement}MB, exceeds limit of ${this.MEMORY_LIMIT}MB`)}async performMemoryCleanup(){if(this.proofCache.size>this.MAX_CACHE_SIZE*.8){const e=Array.from(this.proofCache.entries()),t=e.slice(0,Math.floor(e.length/4));for(const[r]of t)this.proofCache.delete(r);console.log(`ðŸ§¹ Cleaned up ${t.length} proof cache entries`)}if(this.batchCache.size>25){const t=Array.from(this.batchCache.entries()).slice(0,10);for(const[r]of t)this.batchCache.delete(r);console.log(`ðŸ§¹ Cleaned up ${t.length} batch cache entries`)}}getPerformanceStats(){return{circuitRegistry:this.circuitRegistry.getPerformanceProfile(),cache:{proofCacheSize:this.proofCache.size,batchCacheSize:this.batchCache.size,hitRate:this.performanceMonitor.getCacheHitRate()},performance:this.performanceMonitor.getPerformanceReport(),nullifierRegistry:{size:this.nullifierStore.size},optimizationRecommendations:this.performanceMonitor.getOptimizationRecommendations()}}clearOptimizationCaches(){this.proofCache.clear(),this.batchCache.clear(),console.log("âœ… All ZK proof optimization caches cleared")}async generateWitness(e,t,r){const i={};for(const[a,o]of Object.entries(e.publicInputs))i[a]=o;switch(t.id){case"age_verification":i.salt=this.bytesToBigInt(r),i.date_of_birth=e.publicInputs.date_of_birth||0;break;case"income_threshold":i.salt=this.bytesToBigInt(r),i.actual_income=e.publicInputs.actual_income||0,i.income_proof_hash=await this.hashData(JSON.stringify(e.publicInputs.income_proof||{}));break;case"employment_status":i.salt=this.bytesToBigInt(r),i.employer_hash=await this.hashData(e.publicInputs.employer||""),i.employment_proof_hash=await this.hashData(JSON.stringify(e.publicInputs.employment_proof||{}));break;case"selective_disclosure":i.salt=this.bytesToBigInt(r),i.full_credential_hash=await this.hashData(JSON.stringify(e.publicInputs.full_credential||{})),i.selective_fields=e.selectiveFields?.join(",")||"";break;case"membership_proof":i.salt=this.bytesToBigInt(r),i.member_hash=await this.hashData(e.publicInputs.member_data||""),i.membership_path=e.publicInputs.membership_path||[];break;case"identity_verification":i.salt=this.bytesToBigInt(r),i.identity_data=e.publicInputs.identity_data||"",i.biometric_hash=await this.hashData(e.publicInputs.biometric_data||"");break;default:throw new Error(`Unknown circuit type: ${t.id}`)}return i}async generateCircuitProof(e,t,r){const i={pi_a:[this.generateRandomFieldElement(),this.generateRandomFieldElement(),"1"],pi_b:[[this.generateRandomFieldElement(),this.generateRandomFieldElement()],[this.generateRandomFieldElement(),this.generateRandomFieldElement()],["1","0"]],pi_c:[this.generateRandomFieldElement(),this.generateRandomFieldElement(),"1"],protocol:"groth16",curve:"bn128"};return e.constraints>3e3&&(i.optimization="parallelized"),i}async generateNullifier(e,t){const r=e+this.bytesToHex(t)+Date.now().toString(),i=await this.hashData(r);return this.bytesToHex(i)}async generateCommitment(e,t){const r={credentialId:e.credentialId,proofType:e.proofType,publicInputs:e.publicInputs,selectiveFields:e.selectiveFields,salt:this.bytesToHex(t),timestamp:Date.now()},i=await this.hashData(JSON.stringify(r));return this.bytesToHex(i)}async verifyProof(e,t,r){try{if(!e.proof||!e.publicSignals||!e.commitment)return!1;const i=this.circuits.get(e.circuitId);if(!i)return!1;if(this.nullifierStore.has(e.nullifier))return console.warn("Nullifier already used:",e.nullifier),!1;if(t&&e.commitment!==t||e.metadata?.expiresAt&&new Date>new Date(e.metadata.expiresAt))return!1;const a=await this.verifyCircuitProof(i,e.proof,e.publicSignals);return a&&(this.nullifierStore.add(e.nullifier),await this.saveNullifierStore()),a}catch(i){return m.logError("ZK proof verification failed:",i),!1}}async verifyCircuitProof(e,t,r){try{return!t.pi_a||!t.pi_b||!t.pi_c||r.length!==e.publicInputs.length||t.curve!=="bn128"||t.protocol!=="groth16"?!1:this.simulateGroth16Verification(e.verificationKey,t,r)}catch(i){return m.logError("Circuit proof verification failed:",i),!1}}simulateGroth16Verification(e,t,r){return e&&t.pi_a&&t.pi_b&&t.pi_c&&r.length>0&&t.protocol==="groth16"&&t.curve==="bn128"}async createPrivacyPreservingCredential(e,t="selective"){try{const r=d(32),i=JSON.stringify(e),a=await this.hashData(i+this.bytesToHex(r)),o=await this.generateNullifier(e.id,r),n=await this.encryptCredentialData(i,t),s=this.extractPublicAttributes(e,t),c=this.extractPrivateAttributes(e,t);return{id:`zk-${e.id}`,type:Array.isArray(e.type)?e.type.join(","):e.type,commitment:this.bytesToHex(a),nullifierHash:o,encryptedData:n,publicAttributes:s,privateAttributes:c,metadata:{privacyLevel:t,createdAt:new Date().toISOString(),expiresAt:e.expirationDate,issuer:typeof e.issuer=="string"?e.issuer:e.issuer.id,subject:e.credentialSubject.id||"unknown"}}}catch(r){throw new Error(`Failed to create privacy-preserving credential: ${r instanceof Error?r.message:"Unknown error"}`)}}extractPublicAttributes(e,t){switch(t){case"minimal":return{type:e.type,issuer:e.issuer,issuanceDate:e.issuanceDate,expirationDate:e.expirationDate};case"selective":return{type:e.type,issuer:e.issuer,issuanceDate:e.issuanceDate};case"zero_knowledge":return{type:e.type};default:return{}}}extractPrivateAttributes(e,t){const r=Object.keys(e.credentialSubject);switch(t){case"minimal":return r.filter(i=>!["id"].includes(i));case"selective":return r;case"zero_knowledge":return[...r,"issuer","issuanceDate","expirationDate"];default:return r}}async encryptCredentialData(e,t){try{const r=btoa(JSON.stringify(e)),i={ciphertext:new TextEncoder().encode(r)};return this.bytesToHex(i.ciphertext)}catch{const i=await crypto.subtle.generateKey({name:"AES-GCM",length:256},!1,["encrypt","decrypt"]),a=crypto.getRandomValues(new Uint8Array(12)),o=await crypto.subtle.encrypt({name:"AES-GCM",iv:a},i,new TextEncoder().encode(e));return this.bytesToHex(new Uint8Array(o))}}getCircuitInfo(e){return this.circuits.get(e)}listCircuits(){return Array.from(this.circuits.values())}getPrivacyRecommendations(e){const t=["financial","health","government","biometric"],r=["employment","education","professional"],i=e.toLowerCase();return t.some(a=>i.includes(a))?{level:"zero_knowledge",reason:"High-sensitivity data requires maximum privacy protection",recommendedFields:["type","issuer"]}:r.some(a=>i.includes(a))?{level:"selective",reason:"Professional credentials benefit from selective disclosure",recommendedFields:["type","issuer","issuanceDate","title"]}:{level:"minimal",reason:"Basic privacy protection is sufficient for this credential type",recommendedFields:["type","issuer","issuanceDate","expirationDate"]}}bytesToHex(e){return Array.from(e).map(t=>t.toString(16).padStart(2,"0")).join("")}bytesToBigInt(e){return BigInt("0x"+this.bytesToHex(e))}async hashData(e){return S(new TextEncoder().encode(e))}generateRandomFieldElement(){const e=d(32);return this.bytesToBigInt(e).toString()}}const k=new R;export{k as e};
