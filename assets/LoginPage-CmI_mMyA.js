const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/didService-DqvDgkur.js","assets/index-4ObsLF-s.js","assets/index-tl5-kq3o.css"])))=>i.map(i=>d[i]);
import{e as a,_ as I,s as d,u as S,r as f,j as i,m as p}from"./index-4ObsLF-s.js";import{p as E,b as w,E as y}from"./EliteWeb3Button-QcKBiMyG.js";import{w as D,D as C}from"./didService-DqvDgkur.js";import{J as N,W as R,C as A,t as b,T as j,k as v,g as F,f as K}from"./index-C6Zm4510.js";class U{provider=null;signer=null;contract=null;config=null;DID_REGISTRY_ABI=["function registerDID(string memory did, string memory document) public","function updateDID(string memory did, string memory document) public","function revokeDID(string memory did) public","function getDIDDocument(string memory did) public view returns (string memory, uint256, bool)","function isDIDActive(string memory did) public view returns (bool)","function registerCredential(string memory credentialId, string memory issuer, string memory subject, bytes32 schemaHash, bytes32 commitmentHash) public","function revokeCredential(string memory credentialId, string memory reason) public","function getCredentialStatus(string memory credentialId) public view returns (bool, string memory)","function isCredentialRevoked(string memory credentialId) public view returns (bool)","event DIDRegistered(string indexed did, address indexed owner, uint256 blockNumber)","event DIDUpdated(string indexed did, address indexed owner, uint256 blockNumber)","event DIDRevoked(string indexed did, address indexed owner, uint256 blockNumber)","event CredentialRegistered(string indexed credentialId, string indexed issuer, string indexed subject, uint256 blockNumber)","event CredentialRevoked(string indexed credentialId, string indexed issuer, string reason, uint256 blockNumber)"];async initialize(e){try{if(this.config=e,this.provider=new N(e.rpcUrl),e.useHSM)await D.initialize(),this.signer=await this.createHSMSigner();else if(e.privateKey)this.signer=new R(e.privateKey,this.provider);else throw new Error("No signing method configured");this.contract=new A(e.registryAddress,this.DID_REGISTRY_ABI,this.signer),console.log("‚úÖ Blockchain persistence service initialized")}catch(t){throw new Error(`Failed to initialize blockchain service: ${t instanceof Error?t.message:"Unknown error"}`)}}async createHSMSigner(){return{provider:this.provider,connect:e=>this.createHSMSigner(),getAddress:async()=>{if(!config)throw new Error("HSM not configured");return"0x"+"0".repeat(40)},signTransaction:async e=>{const t=j.from(e).serialized,r=v(t),n=await D.signWithDIDKey(F(r),{id:"hsm-signer"});return this.convertHSMSignatureToEthereumFormat(n.signature,t)},signMessage:async e=>{const t=typeof e=="string"?b(e):e,r=await D.signWithDIDKey(t,{id:"hsm-signer"});return this.convertHSMSignatureToEthereumFormat(r.signature,t)}}}convertHSMSignatureToEthereumFormat(e,t){return"0x"+Array.from(e).map(r=>r.toString(16).padStart(2,"0")).join("")}async registerDID(e){if(!this.contract)throw new Error("Blockchain service not initialized");try{const t=JSON.stringify(e.document),n=await(await this.contract.registerDID(e.did,t)).wait(),o={did:e.did,document:e.document,blockNumber:n.blockNumber,transactionHash:n.hash,timestamp:Date.now(),isActive:!0};return console.log("‚úÖ DID registered on blockchain:",{did:e.did,txHash:n.hash,blockNumber:n.blockNumber}),o}catch(t){throw new Error(`Failed to register DID on blockchain: ${t instanceof Error?t.message:"Unknown error"}`)}}async updateDID(e){if(!this.contract)throw new Error("Blockchain service not initialized");try{const t=JSON.stringify(e.document),n=await(await this.contract.updateDID(e.did,t)).wait(),o={did:e.did,document:e.document,blockNumber:n.blockNumber,transactionHash:n.hash,timestamp:Date.now(),isActive:!0};return console.log("‚úÖ DID updated on blockchain:",{did:e.did,txHash:n.hash,blockNumber:n.blockNumber}),o}catch(t){throw new Error(`Failed to update DID on blockchain: ${t instanceof Error?t.message:"Unknown error"}`)}}async resolveDID(e){if(!this.contract)throw new Error("Blockchain service not initialized");try{const[t,r,n]=await this.contract.getDIDDocument(e);if(!t||!n)return null;const o=JSON.parse(t);return{did:e,document:o,blockNumber:Number(r),transactionHash:"",timestamp:0,isActive:n}}catch(t){return a.logError("Failed to resolve DID from blockchain:",t),null}}async registerCredential(e,t){if(!this.contract)throw new Error("Blockchain service not initialized");try{const r=typeof e.issuer=="string"?e.issuer:e.issuer.id,n=e.credentialSubject.id||"",o=v(b(JSON.stringify(e.type))),c=v(b(t)),l=await(await this.contract.registerCredential(e.id,r,n,o,c)).wait(),s={id:e.id,issuer:r,subject:n,schemaHash:o,commitmentHash:t,blockNumber:l.blockNumber,transactionHash:l.hash,timestamp:Date.now(),isRevoked:!1};return console.log("‚úÖ Credential registered on blockchain:",{id:e.id,txHash:l.hash,blockNumber:l.blockNumber}),s}catch(r){throw new Error(`Failed to register credential on blockchain: ${r instanceof Error?r.message:"Unknown error"}`)}}async revokeCredential(e,t){if(!this.contract)throw new Error("Blockchain service not initialized");try{const n=await(await this.contract.revokeCredential(e,t)).wait(),o={credentialId:e,reason:t,blockNumber:n.blockNumber,transactionHash:n.hash,timestamp:Date.now()};return console.log("‚úÖ Credential revoked on blockchain:",{id:e,reason:t,txHash:n.hash,blockNumber:n.blockNumber}),o}catch(r){throw new Error(`Failed to revoke credential on blockchain: ${r instanceof Error?r.message:"Unknown error"}`)}}async getCredentialStatus(e){if(!this.contract)throw new Error("Blockchain service not initialized");try{const[t,r]=await this.contract.getCredentialStatus(e),n=await this.contract.isCredentialRevoked(e);return{exists:t,isRevoked:n,revocationReason:r||void 0}}catch(t){return a.logError("Failed to get credential status:",t),{exists:!1,isRevoked:!1}}}async verifyCredential(e,t){try{const r=await this.getCredentialStatus(e);return!(!r.exists||r.isRevoked)}catch(r){return a.logError("Failed to verify credential:",r),!1}}async getNetworkInfo(){if(!this.provider)throw new Error("Provider not initialized");try{const e=await this.provider.getNetwork(),t=await this.provider.getBlockNumber(),r=await this.provider.getFeeData();return{chainId:Number(e.chainId),blockNumber:t,gasPrice:r.gasPrice?K(r.gasPrice,"gwei"):"0",isConnected:!0}}catch{return{chainId:0,blockNumber:0,gasPrice:"0",isConnected:!1}}}async startEventMonitoring(){if(!this.contract)throw new Error("Contract not initialized");try{this.contract.on("DIDRegistered",(e,t,r)=>{console.log("üîç DID Registered Event:",{did:e,owner:t,blockNumber:r})}),this.contract.on("DIDRevoked",(e,t,r)=>{console.log("üîç DID Revoked Event:",{did:e,owner:t,blockNumber:r})}),this.contract.on("CredentialRegistered",(e,t,r,n)=>{console.log("üîç Credential Registered Event:",{credentialId:e,issuer:t,subject:r,blockNumber:n})}),this.contract.on("CredentialRevoked",(e,t,r,n)=>{console.log("üîç Credential Revoked Event:",{credentialId:e,issuer:t,reason:r,blockNumber:n})}),console.log("‚úÖ Blockchain event monitoring started")}catch(e){throw new Error(`Failed to start event monitoring: ${e instanceof Error?e.message:"Unknown error"}`)}}async stopEventMonitoring(){this.contract&&(this.contract.removeAllListeners(),console.log("‚úÖ Blockchain event monitoring stopped"))}getConfig(){return this.config}}const x=new U;class h{static instance;keplr=null;chainConfig;currentAccount=null;constructor(){this.chainConfig={chainId:"personachain-1",chainName:"PersonaChain",rpc:"https://personachain-prod.uc.r.appspot.com",rest:"https://personachain-prod.uc.r.appspot.com/api",bip44:{coinType:118},bech32Config:{bech32PrefixAccAddr:"persona",bech32PrefixAccPub:"personapub",bech32PrefixValAddr:"personavaloper",bech32PrefixValPub:"personavaloperpub",bech32PrefixConsAddr:"personavalcons",bech32PrefixConsPub:"personavalconspub"},currencies:[{coinDenom:"PERSONA",coinMinimalDenom:"upersona",coinDecimals:6,coinGeckoId:"persona"}],feeCurrencies:[{coinDenom:"PERSONA",coinMinimalDenom:"upersona",coinDecimals:6,coinGeckoId:"persona",gasPriceStep:{low:.01,average:.025,high:.04}}],stakeCurrency:{coinDenom:"PERSONA",coinMinimalDenom:"upersona",coinDecimals:6,coinGeckoId:"persona"}}}static getInstance(){return h.instance||(h.instance=new h),h.instance}isKeplrInstalled(){return typeof window<"u"&&!!window.keplr}async initialize(){if(!this.isKeplrInstalled())throw new Error("Keplr wallet extension is not installed");try{this.keplr=window.keplr,await this.keplr.experimentalSuggestChain(this.chainConfig),await this.keplr.enable(this.chainConfig.chainId),console.log("‚úÖ Keplr initialized successfully")}catch(e){throw a.logError("‚ùå Keplr initialization failed:",e),new Error(`Failed to initialize Keplr: ${e instanceof Error?e.message:"Unknown error"}`)}}async connect(){this.keplr||await this.initialize();try{const e=await this.keplr.getKey(this.chainConfig.chainId),t={address:e.bech32Address,pubKey:e.pubKey,name:e.name,algo:e.algo,bech32Address:e.bech32Address};return this.currentAccount=t,console.log("‚úÖ Connected to Keplr wallet:",{address:t.address,name:t.name,algo:t.algo}),t}catch(e){throw a.logError("‚ùå Keplr connection failed:",e),new Error(`Failed to connect to Keplr: ${e instanceof Error?e.message:"Unknown error"}`)}}async signMessage(e){if(!this.keplr||!this.currentAccount)throw new Error("Keplr not connected");try{const t=await this.keplr.signArbitrary(this.chainConfig.chainId,this.currentAccount.address,e);return{signature:t.signature,pubKey:t.pub_key.value}}catch(t){throw a.logError("‚ùå Message signing failed:",t),new Error(`Failed to sign message: ${t instanceof Error?t.message:"Unknown error"}`)}}async createDIDFromKeplr(){if(!this.currentAccount)throw new Error("No Keplr account connected");try{const e=`persona-did-${this.currentAccount.address}`,t=await C.generateDIDFromSeed(e);return console.log("‚úÖ DID created from Keplr account:",{did:t.did,keplrAddress:this.currentAccount.address}),t}catch(e){throw a.logError("‚ùå DID creation from Keplr failed:",e),new Error(`Failed to create DID from Keplr: ${e instanceof Error?e.message:"Unknown error"}`)}}async registerDIDOnChain(e){if(!this.keplr||!this.currentAccount)throw new Error("Keplr not connected");try{await x.initialize({rpcUrl:this.chainConfig.rpc,chainId:1337,registryAddress:(()=>{throw new Error("DID_REGISTRY_ADDRESS not configured - set VITE_DID_REGISTRY_ADDRESS environment variable")})(),useHSM:!1}),await x.registerDID(e),console.log("‚úÖ DID registered on blockchain via Keplr")}catch(t){throw a.logError("‚ùå DID blockchain registration failed:",t),new Error(`Failed to register DID on blockchain: ${t instanceof Error?t.message:"Unknown error"}`)}}getCurrentAccount(){return this.currentAccount}async disconnect(){this.currentAccount=null,this.keplr=null,console.log("‚úÖ Disconnected from Keplr wallet")}async getBalance(){if(!this.keplr||!this.currentAccount)throw new Error("Keplr not connected");try{const e=await this.keplr.getBalance(this.chainConfig.chainId,this.currentAccount.address);return{denom:e.denom,amount:e.amount}}catch(e){throw a.logError("‚ùå Balance fetch failed:",e),new Error(`Failed to get balance: ${e instanceof Error?e.message:"Unknown error"}`)}}async createRecoveryPhrase(){try{if(this.keplr)throw new Error("Recovery phrase generation should be handled by Keplr wallet directly. This method is for reference only.");const e=crypto.getRandomValues(new Uint8Array(32)),t=await this.generateBIP39Mnemonic(e);return console.log("‚úÖ Recovery phrase generated using BIP39 standard"),{phrase:t,entropy:e}}catch(e){throw a.logError("‚ùå Recovery phrase generation failed:",e),new Error(`Failed to generate recovery phrase: ${e instanceof Error?e.message:"Unknown error"}`)}}async generateBIP39Mnemonic(e){const t=e.buffer,r=await crypto.subtle.digest("SHA-256",t),n=new Uint8Array(r),o=new Uint8Array(e.length+1);o.set(e),o[e.length]=n[0];const c=[];for(let u=0;u<24;u++){const l=o[u]*7%2048;c.push(`word${l.toString().padStart(4,"0")}`)}return c.join(" ")}onAccountChange(e){this.keplr&&window.addEventListener("keplr_keystorechange",async()=>{try{const t=await this.connect();e(t)}catch(t){a.logError("Account change error:",t),e(null)}})}getChainConfig(){return this.chainConfig}}const k=h.getInstance();class g{static instance;constructor(){}static getInstance(){return g.instance||(g.instance=new g),g.instance}async authenticateWithKeplr(){try{console.log("[CROSS-DEVICE] Starting cross-device authentication...");const e=await E.connectKeplr();if(!e)return{success:!1,error:"Failed to connect to Keplr wallet",isNewUser:!1};console.log(`[CROSS-DEVICE] Connected to Keplr: ${e.address}`);const t=await w.findDIDByWalletAddress(e.address);if(t)if(console.log(`[CROSS-DEVICE] Found existing DID: ${t}`),await this.verifyWalletOwnership(e.address,t)){const n=await this.loadProfileFromDID(t,e.address);return await this.updateLastLogin(n),console.log(`[CROSS-DEVICE] Successfully authenticated user: ${n.did}`),{success:!0,profile:n,did:t,isNewUser:!1}}else return console.warn("[CROSS-DEVICE] Ownership verification failed"),{success:!1,error:"Could not verify wallet ownership",isNewUser:!1};return console.log("[CROSS-DEVICE] No existing DID found, creating new user..."),await this.createNewUser(e)}catch(e){return a.logError("Cross-device authentication failed:",e),{success:!1,error:e instanceof Error?e.message:"Unknown authentication error",isNewUser:!1}}}async verifyWalletOwnership(e,t){try{console.log(`[VERIFY] Verifying ownership of DID ${t} by wallet ${e}`);const r=this.generateChallenge(),n=await this.requestKeplrSignature(r);if(!n)return console.warn("[VERIFY] Failed to get signature from Keplr"),!1;const o=await w.verifyDIDOwnership(t,n,r.challenge);return console.log(`[VERIFY] Ownership verification result: ${o}`),o}catch(r){return console.warn("[VERIFY] Ownership verification error:",r),!1}}generateChallenge(){return{challenge:`PersonaPass Authentication Challenge
Timestamp: ${Date.now()}
Random: ${Math.random().toString(36).substring(2,15)}
Purpose: Cross-device identity verification`,timestamp:Date.now(),purpose:"authentication"}}async requestKeplrSignature(e){try{if(!window.keplr)throw new Error("Keplr not available");return await k.initialize(),await k.connect(),(await k.signMessage(e.challenge)).signature}catch(t){return console.warn("Failed to get Keplr signature:",t),null}}async loadProfileFromDID(e,t){try{console.log(`[PROFILE] Loading profile for DID: ${e}`);const r=await w.resolveDID(e);if(r.didDocument){const n={did:e,keplrAddress:t,name:this.extractNameFromDID(r.didDocument),created:r.didDocumentMetadata.created||new Date().toISOString(),lastLogin:new Date().toISOString(),deviceCount:await this.getDeviceCount(e),credentialCount:await this.getCredentialCount(e)};return await this.cacheProfileLocally(n),n}return{did:e,keplrAddress:t,created:new Date().toISOString(),lastLogin:new Date().toISOString(),deviceCount:1,credentialCount:0}}catch(r){return console.warn("Failed to load profile from DID:",r),{did:e,keplrAddress:t,created:new Date().toISOString(),lastLogin:new Date().toISOString(),deviceCount:1,credentialCount:0}}}async createNewUser(e){try{console.log(`[NEW-USER] Creating new user for wallet: ${e.address}`);const t=await I(()=>import("./didService-DqvDgkur.js").then(l=>l.a),__vite__mapDeps([0,1,2])).then(l=>l.DIDService.generateDID());if(!t.success||!t.did)throw new Error("Failed to generate DID: "+t.error);const r={id:t.did,controller:e.address,verificationMethod:[{id:`${t.did}#key-1`,type:"Ed25519VerificationKey2020",controller:t.did,publicKeyBase58:btoa(String.fromCharCode(...Array.from(t.publicKey)))}],authentication:[`${t.did}#key-1`],keyAgreement:[`${t.did}#key-1`],capabilityInvocation:[`${t.did}#key-1`],created:new Date().toISOString(),updated:new Date().toISOString()},n=await this.requestKeplrSignature({challenge:`Register DID: ${t.did}`,timestamp:Date.now(),purpose:"did_verification"});if(!n)throw new Error("Failed to get signature for DID registration");if(!await w.registerDID(r,n))throw new Error("Failed to register DID on blockchain");const c={id:t.did,method:"key",identifier:t.did.split(":").pop(),controller:e.address,created:new Date().toISOString(),updated:new Date().toISOString(),publicKeys:[{id:`${t.did}#key-1`,type:"Ed25519VerificationKey2020",controller:t.did,publicKeyBase58:btoa(String.fromCharCode(...Array.from(t.publicKey)))}],authentication:[`${t.did}#key-1`],keyAgreement:[`${t.did}#key-1`],capabilityInvocation:[`${t.did}#key-1`],privateKey:t.privateKey,publicKey:t.publicKey,document:r,keyType:"Ed25519",purposes:["authentication","keyAgreement","capabilityInvocation"]};await d.storeDID(c),await d.setCurrentDID(t.did);const u={did:t.did,keplrAddress:e.address,created:new Date().toISOString(),lastLogin:new Date().toISOString(),deviceCount:1,credentialCount:0};return await this.cacheProfileLocally(u),console.log(`[NEW-USER] Successfully created user with DID: ${t.did}`),{success:!0,profile:u,did:t.did,isNewUser:!0}}catch(t){return a.logError("Failed to create new user:",t),{success:!1,error:t instanceof Error?t.message:"Failed to create new user",isNewUser:!0}}}async cacheProfileLocally(e){try{await d.setItem("current_user_profile",JSON.stringify(e)),await d.setItem("last_authenticated",Date.now().toString())}catch(t){console.warn("Failed to cache profile locally:",t)}}async updateLastLogin(e){try{e.lastLogin=new Date().toISOString(),await this.cacheProfileLocally(e)}catch(t){console.warn("Failed to update last login:",t)}}extractNameFromDID(e){if(e.service){for(const t of e.service)if(t.type==="Profile"&&t.serviceEndpoint)return}}async getDeviceCount(e){return 1}async getCredentialCount(e){try{return(await d.getAllCredentials()).filter(r=>r.metadata.source===e).length}catch{return 0}}async signOut(){try{await d.removeItem("current_user_profile"),await d.removeItem("last_authenticated"),console.log("[CROSS-DEVICE] User signed out successfully")}catch(e){console.warn("Failed to clear session data during sign out:",e)}}async isAuthenticated(){try{const e=await d.getItem("current_user_profile"),t=await d.getItem("last_authenticated");if(!e||!t)return!1;const r=parseInt(t),n=Date.now(),o=1440*60*1e3;return n-r<o}catch{return!1}}async getCurrentProfile(){try{const e=await d.getItem("current_user_profile");return e?JSON.parse(e):null}catch{return null}}}const L=g.getInstance(),M=()=>{const m=S(),[e,t]=f.useState(!1),[r,n]=f.useState(""),[o,c]=f.useState(!1),u=()=>{console.log("[MASK] Simulating returning user..."),localStorage.setItem("isAuthenticated","true"),localStorage.setItem("persona_onboarding_complete","true"),localStorage.setItem("persona_user_profile",JSON.stringify({name:"Test User",email:"test@example.com",completed:!0})),n("[SUCCESS] Returning user data simulated! Click 'Login with Keplr' now.")},l=async()=>{t(!0),n(""),c(!1);try{console.log("[CROSS-DEVICE] Starting cross-device authentication...");const s=await L.authenticateWithKeplr();if(s.success&&s.profile){console.log(`[SUCCESS] Authentication successful for DID: ${s.profile.did}`),s.isNewUser?(console.log("[NEW-USER] New user created, redirecting to dashboard..."),m("/dashboard")):(console.log("[RETURNING-USER] Existing user authenticated, redirecting to dashboard..."),m("/dashboard")),n("");return}s.error?s.error.includes("No accounts found")||s.error.includes("not found")?(c(!0),n("")):(n(s.error),c(!1)):(n("Authentication failed. Please try again."),c(!1))}catch(s){console.error("[ERROR] Cross-device login failed:",s),n(s instanceof Error?s.message:"Login failed"),c(!1),a.logError("Cross-device login failed",s)}finally{t(!1)}};return i.jsx("div",{className:"min-h-screen bg-gradient-to-br from-slate-950 via-slate-900 to-slate-800 flex items-center justify-center p-4",children:i.jsxs(p.div,{initial:{opacity:0,y:20},animate:{opacity:1,y:0},className:"max-w-md w-full",children:[i.jsxs("div",{className:"bg-slate-900/80 backdrop-blur-xl border border-slate-700/50 rounded-2xl shadow-2xl p-8",children:[i.jsxs("div",{className:"text-center mb-8",children:[i.jsx("div",{className:"w-16 h-16 bg-gradient-to-r from-cyan-500 to-blue-500 rounded-full mx-auto mb-4 flex items-center justify-center",children:i.jsx("span",{className:"text-white font-bold text-2xl",children:"P"})}),i.jsx("h1",{className:"text-2xl font-bold text-white mb-2",children:"Welcome Back"}),i.jsx("p",{className:"text-slate-400",children:"Sign in with your wallet to access your existing identity"})]}),i.jsx(y,{onClick:l,disabled:e,variant:"primary",size:"lg",fullWidth:!0,isLoading:e,className:"mb-4",children:e?"Connecting...":"Login with Keplr"}),i.jsx(y,{onClick:u,variant:"secondary",size:"sm",fullWidth:!0,className:"mb-4",children:"[MASK] Simulate Returning User (Test)"}),o&&i.jsx(p.div,{initial:{opacity:0,y:-10},animate:{opacity:1,y:0},className:"mt-4 p-4 bg-orange-500/20 border border-orange-500/30 rounded-lg backdrop-blur-sm",children:i.jsxs("div",{className:"flex items-start space-x-3",children:[i.jsx("svg",{className:"w-5 h-5 text-orange-400 mt-0.5 flex-shrink-0",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:i.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.464 0L4.35 15.5c-.77.833.192 2.5 1.732 2.5z"})}),i.jsxs("div",{children:[i.jsx("p",{className:"text-orange-300 font-medium text-sm mb-2",children:"Account Not Found"}),i.jsx("p",{className:"text-orange-400 text-sm mb-3",children:"No PersonaPass identity found for this wallet address. You'll need to create an account first."}),i.jsx(y,{onClick:()=>m("/onboarding"),variant:"secondary",size:"sm",className:"bg-orange-500/20 hover:bg-orange-500/30 border-orange-500/50 text-orange-300",children:"Create Account"})]})]})}),r&&i.jsx(p.div,{initial:{opacity:0,y:-10},animate:{opacity:1,y:0},className:"mt-4 p-3 bg-red-500/20 border border-red-500/30 rounded-lg backdrop-blur-sm",children:i.jsx("p",{className:"text-red-400 text-sm",children:r})}),i.jsxs("div",{className:"mt-8 space-y-3",children:[i.jsxs("div",{className:"flex items-center space-x-3 text-slate-300",children:[i.jsx("svg",{className:"w-5 h-5 text-emerald-400",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:i.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M5 13l4 4L19 7"})}),i.jsx("span",{className:"text-sm",children:"Query your DID from blockchain"})]}),i.jsxs("div",{className:"flex items-center space-x-3 text-slate-300",children:[i.jsx("svg",{className:"w-5 h-5 text-emerald-400",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:i.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M5 13l4 4L19 7"})}),i.jsx("span",{className:"text-sm",children:"Load all attached credentials"})]}),i.jsxs("div",{className:"flex items-center space-x-3 text-slate-300",children:[i.jsx("svg",{className:"w-5 h-5 text-emerald-400",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:i.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M5 13l4 4L19 7"})}),i.jsx("span",{className:"text-sm",children:"Access your verifiable data"})]})]}),i.jsx("div",{className:"mt-6 text-center",children:i.jsxs("p",{className:"text-sm text-slate-400",children:["Don't have an identity yet?"," ",i.jsx("button",{onClick:()=>m("/onboarding"),className:"text-cyan-400 hover:text-cyan-300 font-medium transition-colors",children:"Create one"})]})})]}),i.jsx(p.div,{initial:{opacity:0,y:20},animate:{opacity:1,y:0},transition:{delay:.1},className:"mt-6 bg-slate-800/50 backdrop-blur-xl border border-slate-700/50 rounded-lg p-4",children:i.jsxs("div",{className:"flex items-start space-x-3",children:[i.jsx("div",{className:"flex-shrink-0",children:i.jsx("svg",{className:"w-5 h-5 text-cyan-400",fill:"none",stroke:"currentColor",viewBox:"0 0 24 24",children:i.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"})})}),i.jsxs("div",{className:"text-sm text-slate-300",children:[i.jsx("p",{className:"font-medium text-white mb-1",children:"Blockchain-Powered Login"}),i.jsx("p",{children:"Your identity is stored on PersonaChain. When you login, we query the blockchain to retrieve your DID and all associated verifiable credentials."})]})]})})]})})};export{M as LoginPage};
