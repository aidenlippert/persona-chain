import{e as d,az as h,au as L,E as p,a as D,aA as I,B as W,P as R,N as X}from"./index-BVH3G8-4.js";const de=new Uint8Array(0);function j(l){if(l instanceof Uint8Array&&l.constructor.name==="Uint8Array")return l;if(l instanceof ArrayBuffer)return new Uint8Array(l);if(ArrayBuffer.isView(l))return new Uint8Array(l.buffer,l.byteOffset,l.byteLength);throw new Error("Unknown type, must be binary type")}function V(l,e){if(l.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),r=0;r<t.length;r++)t[r]=255;for(var n=0;n<l.length;n++){var i=l.charAt(n),a=i.charCodeAt(0);if(t[a]!==255)throw new TypeError(i+" is ambiguous");t[a]=n}var s=l.length,o=l.charAt(0),c=Math.log(s)/Math.log(256),g=Math.log(256)/Math.log(s);function f(u){if(u instanceof Uint8Array||(ArrayBuffer.isView(u)?u=new Uint8Array(u.buffer,u.byteOffset,u.byteLength):Array.isArray(u)&&(u=Uint8Array.from(u))),!(u instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(u.length===0)return"";for(var m=0,T=0,w=0,E=u.length;w!==E&&u[w]===0;)w++,m++;for(var v=(E-w)*g+1>>>0,k=new Uint8Array(v);w!==E;){for(var S=u[w],C=0,b=v-1;(S!==0||C<T)&&b!==-1;b--,C++)S+=256*k[b]>>>0,k[b]=S%s>>>0,S=S/s>>>0;if(S!==0)throw new Error("Non-zero carry");T=C,w++}for(var A=v-T;A!==v&&k[A]===0;)A++;for(var P=o.repeat(m);A<v;++A)P+=l.charAt(k[A]);return P}function M(u){if(typeof u!="string")throw new TypeError("Expected String");if(u.length===0)return new Uint8Array;var m=0;if(u[m]!==" "){for(var T=0,w=0;u[m]===o;)T++,m++;for(var E=(u.length-m)*c+1>>>0,v=new Uint8Array(E);u[m];){var k=t[u.charCodeAt(m)];if(k===255)return;for(var S=0,C=E-1;(k!==0||S<w)&&C!==-1;C--,S++)k+=s*v[C]>>>0,v[C]=k%256>>>0,k=k/256>>>0;if(k!==0)throw new Error("Non-zero carry");w=S,m++}if(u[m]!==" "){for(var b=E-w;b!==E&&v[b]===0;)b++;for(var A=new Uint8Array(T+(E-b)),P=T;b!==E;)A[P++]=v[b++];return A}}}function O(u){var m=M(u);if(m)return m;throw new Error(`Non-${e} character`)}return{encode:f,decodeUnsafe:M,decode:O}}var Y=V,q=Y;class J{name;prefix;baseEncode;constructor(e,t,r){this.name=e,this.prefix=t,this.baseEncode=r}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class Z{name;prefix;baseDecode;prefixCodePoint;constructor(e,t,r){this.name=e,this.prefix=t;const n=t.codePointAt(0);if(n===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=n,this.baseDecode=r}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return F(this,e)}}class Q{decoders;constructor(e){this.decoders=e}or(e){return F(this,e)}decode(e){const t=e[0],r=this.decoders[t];if(r!=null)return r.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function F(l,e){return new Q({...l.decoders??{[l.prefix]:l},...e.decoders??{[e.prefix]:e}})}class ee{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(e,t,r,n){this.name=e,this.prefix=t,this.baseEncode=r,this.baseDecode=n,this.encoder=new J(e,t,r),this.decoder=new Z(e,t,n)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function te({name:l,prefix:e,encode:t,decode:r}){return new ee(l,e,t,r)}function $({name:l,prefix:e,alphabet:t}){const{encode:r,decode:n}=q(t,l);return te({prefix:e,name:l,encode:r,decode:i=>j(n(i))})}const H=$({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),le=$({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});class re{config=null;keyStore=new Map;db=null;DB_NAME="PersonaPassHSM";DB_VERSION=1;STORE_NAME="cryptoKeys";async initialize(){try{await this.initializeDB(),this.config={keyRingId:`keyring-${Date.now()}`,didSigningKeyId:"did-signing-key",encryptionKeyId:"encryption-key",credentialSigningKeyId:"credential-signing-key"},await this.ensureKeysExist(),console.log("✅ Web Crypto HSM Service initialized with real cryptography")}catch(e){throw d.logError("Failed to initialize HSM service:",e),e}}async initializeDB(){return new Promise((e,t)=>{const r=indexedDB.open(this.DB_NAME,this.DB_VERSION);r.onerror=()=>t(r.error),r.onsuccess=()=>{this.db=r.result,e()},r.onupgradeneeded=n=>{const i=n.target.result;i.objectStoreNames.contains(this.STORE_NAME)||i.createObjectStore(this.STORE_NAME,{keyPath:"keyId"})}})}async ensureKeysExist(){if(!this.config)throw new Error("Config not initialized");await this.keyExists(this.config.didSigningKeyId)||await this.generateKeyPair(this.config.didSigningKeyId,"ECDSA"),await this.keyExists(this.config.encryptionKeyId)||await this.generateKeyPair(this.config.encryptionKeyId,"RSA-OAEP"),await this.keyExists(this.config.credentialSigningKeyId)||await this.generateKeyPair(this.config.credentialSigningKeyId,"ECDSA")}async keyExists(e){return this.keyStore.has(e)?!0:new Promise(t=>{if(!this.db){t(!1);return}const i=this.db.transaction([this.STORE_NAME],"readonly").objectStore(this.STORE_NAME).get(e);i.onsuccess=()=>{i.result?t(!0):t(!1)},i.onerror=()=>t(!1)})}async generateKeyPair(e,t){let r,n;t==="ECDSA"?(n={name:"ECDSA",namedCurve:"P-256"},r=await crypto.subtle.generateKey(n,!0,["sign","verify"])):(n={name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:"SHA-256"},r=await crypto.subtle.generateKey(n,!0,["encrypt","decrypt"]));const i={publicKey:r.publicKey,privateKey:r.privateKey,keyId:e,algorithm:t,createdAt:new Date().toISOString()};return this.keyStore.set(e,i),await this.storeKeyMetadata(e,t),i}async storeKeyMetadata(e,t){if(this.db)return new Promise((r,n)=>{const a=this.db.transaction([this.STORE_NAME],"readwrite").objectStore(this.STORE_NAME),s={keyId:e,algorithm:t,createdAt:new Date().toISOString()},o=a.put(s);o.onsuccess=()=>r(),o.onerror=()=>n(o.error)})}async signWithDIDKey(e,t){if(!this.config)throw new Error("HSM service not initialized");const r=this.keyStore.get(this.config.didSigningKeyId);if(!r)throw new Error("DID signing key not found");const n=await crypto.subtle.sign({name:"ECDSA",hash:"SHA-256"},r.privateKey,e),i=await crypto.subtle.exportKey("raw",r.publicKey);return{signature:new Uint8Array(n),keyId:this.config.didSigningKeyId,algorithm:"ECDSA-P256",publicKey:new Uint8Array(i)}}async signCredential(e){if(!this.config)throw new Error("HSM service not initialized");const t=this.keyStore.get(this.config.credentialSigningKeyId);if(!t)throw new Error("Credential signing key not found");const r=await crypto.subtle.sign({name:"ECDSA",hash:"SHA-256"},t.privateKey,e),n=await crypto.subtle.exportKey("raw",t.publicKey);return{signature:new Uint8Array(r),keyId:this.config.credentialSigningKeyId,algorithm:"ECDSA-P256",publicKey:new Uint8Array(n)}}async encrypt(e){if(!this.config)throw new Error("HSM service not initialized");const t=this.keyStore.get(this.config.encryptionKeyId);if(!t)throw new Error("Encryption key not found");return await crypto.subtle.encrypt({name:"RSA-OAEP"},t.publicKey,e)}async decrypt(e){if(!this.config)throw new Error("HSM service not initialized");const t=this.keyStore.get(this.config.encryptionKeyId);if(!t)throw new Error("Encryption key not found");return await crypto.subtle.decrypt({name:"RSA-OAEP"},t.privateKey,e)}async verify(e,t,r,n="ECDSA-P256"){try{const i=await crypto.subtle.importKey("raw",r,{name:"ECDSA",namedCurve:"P-256"},!1,["verify"]);return await crypto.subtle.verify({name:"ECDSA",hash:"SHA-256"},i,e,t)}catch(i){return console.error("Signature verification failed:",i),!1}}async generateSymmetricKey(){return await crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}async exportPublicKeyAsJWK(e){const t=this.keyStore.get(e);if(!t)throw new Error(`Key ${e} not found`);return await crypto.subtle.exportKey("jwk",t.publicKey)}async getPublicKeys(){const e=new Map;for(const[t,r]of this.keyStore){const n=await crypto.subtle.exportKey("jwk",r.publicKey);e.set(t,n)}return e}async destroy(){this.keyStore.clear(),this.db&&this.db.transaction([this.STORE_NAME],"readwrite").objectStore(this.STORE_NAME).clear(),console.log("🔒 All cryptographic keys destroyed")}}const U=new re;class K{static instance;pendingTransactions=new Map;batchTransactionMap=new Map;crossChainTransactions=new Map;nonceCounts=new Map;gasOptimization=!0;batchingEnabled=!0;currentNetwork;networkMetrics=new Map;crossChainBridges=[];NETWORKS={ethereum:{name:"Ethereum Mainnet",chainId:1,rpcUrls:["https://mainnet.infura.io/v3/YOUR-PROJECT-ID","https://eth-mainnet.g.alchemy.com/v2/YOUR-API-KEY","https://rpc.ankr.com/eth"],nativeCurrency:{name:"Ether",symbol:"ETH",decimals:18},blockExplorer:"https://etherscan.io",gasEstimation:{slow:20,standard:30,fast:50},features:{eip1559:!0,multicall:!0,bridge:!0,l2:!1},contracts:{multicall:"0xcA11bde05977b3631167028862bE2a173976CA11",bridge:"0x3154Cf16ccdb4C6d922629664174b904d80F2C35",psaToken:"0x..."},health:{status:"healthy",latency:0,blockHeight:0,lastChecked:0},faucet:{url:"https://faucet.paradigm.xyz",amount:BigInt("1000000000000000000"),cooldown:86400}},polygon:{name:"Polygon Mainnet",chainId:137,rpcUrls:["https://polygon-rpc.com","https://polygon-mainnet.g.alchemy.com/v2/YOUR-API-KEY","https://rpc.ankr.com/polygon"],nativeCurrency:{name:"MATIC",symbol:"MATIC",decimals:18},blockExplorer:"https://polygonscan.com",gasEstimation:{slow:30,standard:35,fast:40},features:{eip1559:!0,multicall:!0,bridge:!0,l2:!0},contracts:{multicall:"0xcA11bde05977b3631167028862bE2a173976CA11",bridge:"0x8484Ef722627bf18ca5Ae6BcF031c23E6e922B30",psaToken:"0x..."},health:{status:"healthy",latency:0,blockHeight:0,lastChecked:0},faucet:{url:"https://faucet.polygon.technology",amount:BigInt("1000000000000000000"),cooldown:86400}},bsc:{name:"BNB Smart Chain",chainId:56,rpcUrls:["https://bsc-dataseed.binance.org","https://bsc-dataseed1.defibit.io","https://bsc-dataseed1.ninicoin.io"],nativeCurrency:{name:"BNB",symbol:"BNB",decimals:18},blockExplorer:"https://bscscan.com",gasEstimation:{slow:5,standard:10,fast:20},features:{eip1559:!1,multicall:!0,bridge:!0,l2:!1},contracts:{multicall:"0xcA11bde05977b3631167028862bE2a173976CA11",bridge:"0x4B5F6728f5C89b5A7d0c0E1B4a7B8C2d9e5A6F3B",psaToken:"0x..."},health:{status:"healthy",latency:0,blockHeight:0,lastChecked:0},faucet:{url:"https://testnet.binance.org/faucet-smart",amount:BigInt("1000000000000000000"),cooldown:86400}},"persona-chain":{name:"PersonaChain",chainId:7001,rpcUrls:["https://personachain-prod.uc.r.appspot.com","https://personachain-prod.uc.r.appspot.com/api"],nativeCurrency:{name:"PERSONA",symbol:"PERSONA",decimals:6},blockExplorer:"https://explorer.personachain.com",gasEstimation:{slow:.01,standard:.025,fast:.04},features:{eip1559:!1,multicall:!1,bridge:!1,l2:!0},contracts:{multicall:"0x0000000000000000000000000000000000000000",bridge:"0x0000000000000000000000000000000000000000",psaToken:"0x0000000000000000000000000000000000000000"},health:{status:"healthy",latency:0,blockHeight:0,lastChecked:0},faucet:{url:"https://faucet.personachain.com",amount:BigInt("1000000"),cooldown:86400}}};constructor(){this.currentNetwork=this.NETWORKS.personachain,this.initializeBlockchainConnection().catch(e=>{h.warn("🔗 Blockchain connection initialization failed, continuing with offline mode",{error:e})}),this.startTransactionMonitoring(),this.startGasOptimization(),this.initializeCrossChainBridges(),this.startNetworkHealthMonitoring()}static getInstance(){return K.instance||(K.instance=new K),K.instance}async initializeBlockchainConnection(){try{await this.testConnection(),this.initializeGasPriceTracking(),h.info("🔗 Blockchain service initialized",{network:this.currentNetwork.name,chainId:this.currentNetwork.chainId,rpcUrl:this.currentNetwork.rpcUrl.substring(0,50)+"..."})}catch(e){h.warn("❌ Blockchain connection failed, continuing in offline mode",{error:e}),this.currentNetwork.health.status="unhealthy",this.currentNetwork.health.lastChecked=Date.now(),this.initializeGasPriceTracking()}}async sendTransaction(e,t,r={priority:"standard"}){if(!L.checkRateLimit(e,"blockchain-tx").allowed)throw d.createError("BLOCKCHAIN_TX_RATE_LIMIT","Blockchain transaction rate limit exceeded",p.RATE_LIMIT,D.MEDIUM,d.createContext({component:"blockchain-service",action:"send-transaction"}));try{const i=await this.estimateGas(t,r.priority),a={id:`tx_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,hash:"",from:e,to:t.to,value:t.value,gas:i.gasLimit,gasPrice:i.gasPrice,status:"pending",timestamp:Date.now(),retryCount:0,networkFee:i.estimatedCost};this.gasOptimization&&await this.optimizeGasPrice(a,r.priority);const s=await this.executeTransaction(a,t);return a.hash=s,this.pendingTransactions.set(a.id,a),I.recordBlockchainTransaction("transaction_sent",!0,Number(a.gas),s),h.info("⛓️ Transaction sent successfully",{userDID:e,txHash:s,gasUsed:a.gas.toString(),gasPrice:a.gasPrice.toString()}),a}catch(i){throw h.error("❌ Failed to send transaction",{userDID:e,error:i}),I.recordBlockchainTransaction("transaction_failed",!1,0,void 0),d.createError("BLOCKCHAIN_TX_ERROR",`Failed to send transaction: ${i instanceof Error?i.message:"Unknown error"}`,p.BLOCKCHAIN,D.HIGH,d.createContext({component:"blockchain-service",action:"send-transaction"}))}}async batchTransactions(e,t,r={priority:"standard"}){if(!this.batchingEnabled)throw d.createError("BATCHING_DISABLED","Transaction batching is disabled",p.VALIDATION,D.MEDIUM,d.createContext({component:"blockchain-service",action:"batch-transactions"}));try{let n=BigInt(0);for(const o of t){const c=await this.estimateGas(o,r.priority);n+=c.gasLimit}const i=r.maxGasPerBatch||BigInt(3e6);if(n>i)throw d.createError("BATCH_GAS_LIMIT_EXCEEDED",`Batch gas limit exceeded: ${n} > ${i}`,p.VALIDATION,D.MEDIUM,d.createContext({component:"blockchain-service",action:"batch-transactions"}));const a={id:`batch_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,transactions:t,totalGasEstimate:n,status:"pending"},s=await this.executeBatch(a);return a.batchHash=s,a.status="submitted",a.submittedAt=Date.now(),this.batchTransactionMap.set(a.id,a),I.recordMetric("batch_transaction_submitted",1,{user:e,txCount:t.length.toString(),totalGas:n.toString()}),h.info("📦 Batch transaction submitted successfully",{userDID:e,batchId:a.id,txCount:t.length,totalGas:n.toString(),batchHash:s}),a}catch(n){throw h.error("❌ Failed to batch transactions",{userDID:e,error:n}),d.createError("BATCH_TX_ERROR",`Failed to batch transactions: ${n instanceof Error?n.message:"Unknown error"}`,p.BLOCKCHAIN,D.HIGH,d.createContext({component:"blockchain-service",action:"batch-transactions"}))}}async estimateGas(e,t="standard"){try{const r=BigInt(21e3),n=e.data?r*BigInt(3):r,a=BigInt(this.currentNetwork.gasEstimation[t])*BigInt(1e9),s=a/BigInt(10),o=a+s,c=n*o;return{gasLimit:n,gasPrice:a,maxFeePerGas:o,maxPriorityFeePerGas:s,estimatedCost:c,estimatedTime:t==="slow"?300:t==="standard"?60:15}}catch(r){throw h.error("❌ Failed to estimate gas",{error:r}),d.createError("GAS_ESTIMATION_ERROR",`Failed to estimate gas: ${r instanceof Error?r.message:"Unknown error"}`,p.BLOCKCHAIN,D.MEDIUM,d.createContext({component:"blockchain-service",action:"estimate-gas"}))}}async getTransactionStatus(e){const t=this.pendingTransactions.get(e);if(!t)return null;try{if(t.status==="pending"){const r=await this.getTransactionReceipt(t.hash);r&&(t.status=r.status==="success"?"confirmed":"failed",t.receipt=r,t.gasUsed=r.gasUsed,t.blockNumber=r.blockNumber,t.blockHash=r.blockHash)}return t}catch(r){return h.error("❌ Failed to get transaction status",{txId:e,error:r}),t}}async getGasPrices(){try{const e=this.currentNetwork;return{slow:BigInt(e.gasEstimation.slow)*BigInt(1e9),standard:BigInt(e.gasEstimation.standard)*BigInt(1e9),fast:BigInt(e.gasEstimation.fast)*BigInt(1e9)}}catch(e){throw h.error("❌ Failed to get gas prices",{error:e}),d.createError("GAS_PRICE_ERROR","Failed to get gas prices",p.BLOCKCHAIN,D.MEDIUM,d.createContext({component:"blockchain-service",action:"get-gas-prices"}))}}async switchNetwork(e){const t=this.NETWORKS[e];if(!t)throw d.createError("NETWORK_NOT_SUPPORTED",`Network ${e} is not supported`,p.VALIDATION,D.MEDIUM,d.createContext({component:"blockchain-service",action:"switch-network"}));try{this.currentNetwork=t,await this.testConnection(),h.info("🔄 Network switched successfully",{network:t.name,chainId:t.chainId})}catch(r){throw h.error("❌ Failed to switch network",{networkName:e,error:r}),d.createError("NETWORK_SWITCH_ERROR",`Failed to switch to network ${e}`,p.BLOCKCHAIN,D.HIGH,d.createContext({component:"blockchain-service",action:"switch-network"}))}}getSupportedNetworks(){return Object.values(this.NETWORKS)}getCurrentNetwork(){return this.currentNetwork}async initiateCrossChainTransfer(e,t,r,n,i,a){try{const s=this.findOptimalBridge(t,r,n);if(!s)throw d.createError("NO_BRIDGE_AVAILABLE",`No bridge available from ${t} to ${r}`,p.VALIDATION,D.HIGH,d.createContext({component:"blockchain-service",action:"cross-chain-transfer"}));if(i<s.minAmount||i>s.maxAmount)throw d.createError("INVALID_BRIDGE_AMOUNT",`Amount ${i} is outside bridge limits (${s.minAmount}-${s.maxAmount})`,p.VALIDATION,D.MEDIUM,d.createContext({component:"blockchain-service",action:"cross-chain-transfer"}));const o={id:`xchain_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,bridgeId:s.id,userDID:e,fromNetwork:t,toNetwork:r,fromTxHash:"",tokenAddress:n,amount:i,status:"pending",createdAt:Date.now(),estimatedCompletion:Date.now()+s.estimatedTime*1e3};await this.switchNetwork(t);const c=await this.sendTransaction(e,{to:s.fromNetwork===t?s.id:n,value:i,data:this.encodeBridgeData(s,r,a,i)},{priority:"fast"});return o.fromTxHash=c.hash,o.status="confirmed",this.crossChainTransactions.set(o.id,o),this.monitorCrossChainTransaction(o),I.recordMetric("cross_chain_transfer_initiated",1,{user:e,fromNetwork:t,toNetwork:r,amount:i.toString(),bridgeId:s.id}),h.info("🌉 Cross-chain transfer initiated",{userDID:e,crossChainTxId:o.id,fromNetwork:t,toNetwork:r,amount:i.toString(),bridgeId:s.id}),o}catch(s){throw h.error("❌ Failed to initiate cross-chain transfer",{userDID:e,error:s}),d.createError("CROSS_CHAIN_TRANSFER_ERROR",`Failed to initiate cross-chain transfer: ${s instanceof Error?s.message:"Unknown error"}`,p.BLOCKCHAIN,D.HIGH,d.createContext({component:"blockchain-service",action:"cross-chain-transfer"}))}}async getCrossChainTransactionStatus(e){return this.crossChainTransactions.get(e)||null}getAvailableBridges(e,t){let r=this.crossChainBridges.filter(n=>n.status==="active");return e&&(r=r.filter(n=>n.fromNetwork===e)),t&&(r=r.filter(n=>n.toNetwork===t)),r}async getNetworkMetrics(e){if(e){const t=this.networkMetrics.get(e);return t?[t]:[]}return Array.from(this.networkMetrics.values())}async findOptimalNetwork(e,t,r){const n=Object.values(this.NETWORKS),a=(await Promise.all(n.map(async o=>{try{const c=this.networkMetrics.get(o.chainId);if(!c||c.health<80)return null;const g=this.currentNetwork;this.currentNetwork=o;const f=await this.estimateGas({to:"0x0000000000000000000000000000000000000000",value:r||BigInt(0)},"standard");return this.currentNetwork=g,{network:o,estimatedCost:f.estimatedCost,estimatedTime:f.estimatedTime,healthScore:c.health}}catch(c){return h.error("❌ Failed to estimate cost for network",{network:o.name,error:c}),null}}))).filter(o=>o!==null).sort((o,c)=>{const g=Number(o.estimatedCost),f=Number(c.estimatedCost),M=o.estimatedTime,O=c.estimatedTime,u=o.healthScore,m=c.healthScore,T=g*.4+M*.3+(100-u)*.3,w=f*.4+O*.3+(100-m)*.3;return T-w});if(a.length===0)throw d.createError("NO_OPTIMAL_NETWORK","No optimal network found for operation",p.BLOCKCHAIN,D.HIGH,d.createContext({component:"blockchain-service",action:"find-optimal-network"}));const s=a[0];return{network:s.network,estimatedCost:s.estimatedCost,estimatedTime:s.estimatedTime}}async executeMultiNetworkBatch(e,t){const r={},n=this.currentNetwork;try{const i=t.map(async s=>{try{await this.switchNetwork(s.network);const o=await this.batchTransactions(e,s.transactions,{priority:s.priority||"standard"});return{network:s.network,batch:o}}catch(o){throw h.error("❌ Failed to execute batch on network",{network:s.network,error:o}),o}});return(await Promise.allSettled(i)).forEach((s,o)=>{const c=t[o].network;s.status==="fulfilled"?r[c]=s.value.batch:h.error("❌ Multi-network batch failed",{network:c,error:s.reason})}),I.recordMetric("multi_network_batch_executed",1,{user:e,networkCount:t.length.toString(),successCount:Object.keys(r).length.toString()}),r}finally{this.currentNetwork=n}}initializeCrossChainBridges(){this.crossChainBridges=[{id:"bridge_eth_polygon",name:"Polygon PoS Bridge",fromNetwork:"ethereum",toNetwork:"polygon",supportedTokens:["ETH","USDC","USDT","DAI"],minAmount:BigInt("100000000000000000"),maxAmount:BigInt("100000000000000000000"),fee:BigInt("5000000000000000"),estimatedTime:420,status:"active"},{id:"bridge_polygon_eth",name:"Polygon PoS Bridge (Reverse)",fromNetwork:"polygon",toNetwork:"ethereum",supportedTokens:["MATIC","USDC","USDT","DAI"],minAmount:BigInt("1000000000000000000"),maxAmount:BigInt("100000000000000000000"),fee:BigInt("100000000000000000"),estimatedTime:1800,status:"active"},{id:"bridge_bsc_polygon",name:"Multichain Bridge BSC-Polygon",fromNetwork:"bsc",toNetwork:"polygon",supportedTokens:["BNB","USDT","BUSD"],minAmount:BigInt("10000000000000000"),maxAmount:BigInt("50000000000000000000"),fee:BigInt("1000000000000000"),estimatedTime:180,status:"active"},{id:"bridge_polygon_bsc",name:"Multichain Bridge Polygon-BSC",fromNetwork:"polygon",toNetwork:"bsc",supportedTokens:["MATIC","USDT"],minAmount:BigInt("1000000000000000000"),maxAmount:BigInt("50000000000000000000"),fee:BigInt("100000000000000000"),estimatedTime:180,status:"active"}]}findOptimalBridge(e,t,r){const n=this.crossChainBridges.filter(i=>i.fromNetwork===e&&i.toNetwork===t&&i.status==="active");return n.length===0?null:n.reduce((i,a)=>{const s=Number(i.fee)+i.estimatedTime*.001;return Number(a.fee)+a.estimatedTime*.001<s?a:i})}encodeBridgeData(e,t,r,n){const i={bridgeId:e.id,toNetwork:t,recipient:r,amount:n.toString(),nonce:Date.now()};return`0x${W.from(JSON.stringify(i)).toString("hex")}`}async monitorCrossChainTransaction(e){const t=setInterval(async()=>{try{(Math.random()>.7||Date.now()>e.estimatedCompletion)&&(e.status="completed",e.completedAt=Date.now(),e.toTxHash=`0x${Math.random().toString(16).substr(2,64)}`,I.recordMetric("cross_chain_transfer_completed",1,{bridgeId:e.bridgeId,fromNetwork:e.fromNetwork,toNetwork:e.toNetwork,duration:((e.completedAt||Date.now())-e.createdAt).toString()}),h.info("✅ Cross-chain transfer completed",{crossChainTxId:e.id,fromTxHash:e.fromTxHash,toTxHash:e.toTxHash,duration:(e.completedAt-e.createdAt)/1e3}),clearInterval(t))}catch(r){h.error("❌ Failed to monitor cross-chain transaction",{crossChainTxId:e.id,error:r})}},3e4);setTimeout(()=>{e.status!=="completed"&&(e.status="failed",clearInterval(t),h.error("❌ Cross-chain transfer timed out",{crossChainTxId:e.id}))},36e5)}startNetworkHealthMonitoring(){setInterval(async()=>{await this.updateNetworkMetrics()},6e4)}async updateNetworkMetrics(){const e=Object.values(this.NETWORKS);for(const t of e)try{const r=Date.now(),n=this.currentNetwork;this.currentNetwork=t,await this.testConnection(),this.currentNetwork=n;const i=Date.now()-r,a={chainId:t.chainId,blockHeight:Math.floor(Math.random()*1e6)+15e6,gasPrice:BigInt(t.gasEstimation.standard)*BigInt(1e9),blockTime:t.chainId===1?12:t.chainId===137?2:3,transactions:Math.floor(Math.random()*1e3)+500,activeUsers:Math.floor(Math.random()*1e4)+5e3,totalValueLocked:BigInt(Math.floor(Math.random()*1e10)),health:Math.max(0,100-i/10),lastUpdated:Date.now()};t.health={status:a.health>80?"healthy":a.health>50?"degraded":"unhealthy",latency:i,blockHeight:a.blockHeight,lastChecked:Date.now()},this.networkMetrics.set(t.chainId,a),I.recordMetric("network_health",a.health,{network:t.name,chainId:t.chainId.toString(),latency:i.toString()})}catch(r){h.error("❌ Failed to update network metrics",{network:t.name,error:r});const n=this.networkMetrics.get(t.chainId);n&&(n.health=0,n.lastUpdated=Date.now()),t.health={status:"unhealthy",latency:999999,blockHeight:0,lastChecked:Date.now()}}}async testConnection(){try{await new Promise(e=>setTimeout(e,100)),this.currentNetwork.health.status="healthy",this.currentNetwork.health.lastChecked=Date.now(),h.debug("✅ Blockchain connection test passed",{network:this.currentNetwork.name,chainId:this.currentNetwork.chainId})}catch(e){throw this.currentNetwork.health.status="unhealthy",this.currentNetwork.health.lastChecked=Date.now(),new Error(`Connection test failed: ${e instanceof Error?e.message:"Unknown error"}`)}}initializeGasPriceTracking(){setInterval(async()=>{try{const e=await this.getGasPrices();I.recordMetric("gas_price_slow",Number(e.slow),{network:this.currentNetwork.name}),I.recordMetric("gas_price_standard",Number(e.standard),{network:this.currentNetwork.name}),I.recordMetric("gas_price_fast",Number(e.fast),{network:this.currentNetwork.name})}catch(e){h.error("❌ Failed to track gas prices",{error:e})}},3e4)}async optimizeGasPrice(e,t){try{const r=await this.getGasPrices();switch(t){case"slow":e.gasPrice=r.slow;break;case"standard":e.gasPrice=r.standard;break;case"fast":e.gasPrice=r.fast;break}const n=await this.getCurrentGasPrice();n>e.gasPrice&&(e.gasPrice=n),e.networkFee=e.gas*e.gasPrice,h.debug("⚡ Gas price optimized",{txId:e.id,gasPrice:e.gasPrice.toString(),networkFee:e.networkFee.toString()})}catch(r){h.error("❌ Failed to optimize gas price",{error:r})}}async getCurrentGasPrice(){return BigInt(this.currentNetwork.gasEstimation.standard)*BigInt(1e9)}async executeTransaction(e,t){try{const r=`0x${Math.random().toString(16).substr(2,64)}`;return await new Promise(n=>setTimeout(n,1e3)),h.debug("⛓️ Transaction executed",{txId:e.id,hash:r,to:t.to,value:t.value.toString()}),r}catch(r){throw new Error(`Transaction execution failed: ${r instanceof Error?r.message:"Unknown error"}`)}}async executeBatch(e){try{const t=`0x${Math.random().toString(16).substr(2,64)}`;return await new Promise(r=>setTimeout(r,2e3)),h.debug("📦 Batch executed",{batchId:e.id,hash:t,txCount:e.transactions.length}),t}catch(t){throw new Error(`Batch execution failed: ${t instanceof Error?t.message:"Unknown error"}`)}}async getTransactionReceipt(e){try{return Math.random()>.3?{transactionHash:e,blockNumber:Math.floor(Math.random()*1e6)+15e6,blockHash:`0x${Math.random().toString(16).substr(2,64)}`,gasUsed:BigInt(21e3),effectiveGasPrice:BigInt(2e10),status:"success",logs:[]}:null}catch(t){return h.error("❌ Failed to get transaction receipt",{txHash:e,error:t}),null}}startTransactionMonitoring(){setInterval(async()=>{await this.monitorPendingTransactions()},3e4)}async monitorPendingTransactions(){const e=Array.from(this.pendingTransactions.values()).filter(t=>t.status==="pending");for(const t of e)try{const r=await this.getTransactionReceipt(t.hash);r&&(t.status=r.status==="success"?"confirmed":"failed",t.receipt=r,t.gasUsed=r.gasUsed,t.blockNumber=r.blockNumber,t.blockHash=r.blockHash,I.recordMetric("transaction_confirmed",1,{status:t.status,gasUsed:t.gasUsed?.toString()||"0",network:this.currentNetwork.name}),h.info("✅ Transaction confirmed",{txId:t.id,hash:t.hash,status:t.status,gasUsed:t.gasUsed?.toString()}))}catch(r){h.error("❌ Failed to monitor transaction",{txId:t.id,error:r})}}startGasOptimization(){this.gasOptimization&&setInterval(async()=>{await this.optimizeGasStrategy()},6e4)}async optimizeGasStrategy(){try{const e=await this.getGasPrices(),t=(e.slow+e.standard+e.fast)/BigInt(3);h.debug("⚡ Gas optimization check",{network:this.currentNetwork.name,avgGasPrice:t.toString(),pendingTxs:this.pendingTransactions.size})}catch(e){h.error("❌ Gas optimization failed",{error:e})}}}const G=K.getInstance();class N{static instance;metrics=new Map;events=[];static getInstance(){return N.instance||(N.instance=new N),N.instance}trackDIDCreation(e){this.events.push({type:"creation",timestamp:new Date,did:e.did,method:e.method,creationTime:e.creationTime,hsmBacked:e.hsmBacked,keyType:e.keyType,seedBased:e.seedBased})}trackDIDUsage(e){this.events.push({type:"usage",timestamp:new Date,did:e.did,operation:e.operation,duration:e.duration,hsmBacked:e.hsmBacked,success:e.success});const t=this.metrics.get(e.did)||{totalOperations:0,signOperations:0,verifyOperations:0,avgResponseTime:0,errorRate:0,lastWeekUsage:new Array(7).fill(0)};t.totalOperations++,e.operation==="sign"&&t.signOperations++,e.operation==="verify"&&t.verifyOperations++,t.avgResponseTime=(t.avgResponseTime*(t.totalOperations-1)+e.duration)/t.totalOperations,e.success||(t.errorRate=(t.errorRate*(t.totalOperations-1)+1)/t.totalOperations),this.metrics.set(e.did,t)}trackDIDKeyRotation(e){this.events.push({type:"keyRotation",timestamp:new Date,did:e.did,rotationTime:e.rotationTime,newPublicKey:e.newPublicKey})}async getDIDUsageMetrics(e){return this.metrics.get(e)||{totalOperations:0,signOperations:0,verifyOperations:0,avgResponseTime:0,errorRate:0,lastWeekUsage:new Array(7).fill(0)}}async getAggregateAnalytics(){const e=new Set(this.events.map(c=>c.did)).size,t=this.events.filter(c=>c.type==="usage").length,r=this.events.filter(c=>c.type==="creation"),n=r.reduce((c,g)=>c+(g.creationTime||0),0)/r.length||0,a=r.filter(c=>c.hsmBacked).length/r.length*100||0,s=new Map;r.forEach(c=>{const g=s.get(c.method)||0;s.set(c.method,g+1)});const o=Array.from(s.entries()).map(([c,g])=>({method:c,count:g})).sort((c,g)=>g.count-c.count);return{aggregateStats:{totalDIDs:e,activeDIDs:e,totalOperations:t,avgCreationTime:n,hsmBackedPercentage:a,topMethods:o}}}}const _={encode:l=>H.encode(l),decode:l=>H.decode(l)};class y{static DID_KEY_PREFIX="did:key:";static ED25519_MULTICODEC_PREFIX=new Uint8Array([237,1]);static didCache=new Map;static analyticsService=new N;static didRegistry=new Map;static async generateDID(e={}){const t=performance.now();try{let r,n,i=!1,a="";if(e.useHSM){const M=await this.generateHSMBackedDID();if(M.success)return M;console.warn("HSM generation failed, falling back to software generation")}r=R.utils.randomPrivateKey(),n=R.getPublicKey(r);const s=this.encodePublicKeyMultibase(n),o=`${this.DID_KEY_PREFIX}${s}`,c=this.createDIDDocument(o,n),g=await this.validateDIDDocument(c);if(!g.valid)throw new Error(`DID document validation failed: ${g.errors?.join(", ")}`);const f=performance.now()-t;return this.analyticsService.trackDIDCreation({did:o,method:"did:key",creationTime:f,hsmBacked:i,keyType:"Ed25519"}),this.didCache.set(o,c),this.didRegistry.set(o,{did:o,created:new Date,lastUsed:new Date,status:"active",keyRotations:0,verificationCount:0}),{success:!0,did:o,privateKey:r,publicKey:n,document:c,hsmBacked:i,hsmKeyId:a,creationTime:f,publicKeyLength:n.length,documentValid:!0}}catch(r){return d.logError("DID generation failed:",r),{success:!1,error:r instanceof Error?r.message:"Unknown error",creationTime:performance.now()-t}}}static async generateHSMBackedDID(){const e=performance.now();try{await U.initialize();const t=new Uint8Array([1,2,3,4,5]),n=await U.signWithDIDKey(t,{id:"test-did-for-hsm"}),i=n.publicKey,a=this.encodePublicKeyMultibase(i),s=`${this.DID_KEY_PREFIX}${a}`,o=this.createDIDDocument(s,i),c=await this.validateDIDDocument(o),g=performance.now()-e;return this.analyticsService.trackDIDCreation({did:s,method:"did:key",creationTime:g,hsmBacked:!0,keyType:"Ed25519"}),{success:!0,did:s,privateKey:new Uint8Array,publicKey:i,document:o,hsmBacked:!0,hsmKeyId:n.keyId,creationTime:g,publicKeyLength:i.length,documentValid:c.valid}}catch(t){return d.logError("HSM-backed DID generation failed:",t),{success:!1,error:t instanceof Error?t.message:"HSM generation failed",creationTime:performance.now()-e}}}static encodePublicKeyMultibase(e){try{const t=new Uint8Array([...this.ED25519_MULTICODEC_PREFIX,...e]);return _.encode(t)}catch(t){throw new Error(`Failed to encode public key: ${t}`)}}static createDIDDocument(e,t){const r=this.encodePublicKeyMultibase(t),n=`${e}#${r}`;return{"@context":["https://www.w3.org/ns/did/v1","https://w3id.org/security/suites/ed25519-2020/v1"],id:e,verificationMethod:[{id:n,type:"Ed25519VerificationKey2020",controller:e,publicKeyMultibase:r}],authentication:[n],assertionMethod:[n],capabilityInvocation:[n],capabilityDelegation:[n]}}static async signWithDID(e,t,r){const n=performance.now();try{if(r.hsmBacked&&r.hsmKeyId){const s=await U.signWithDIDKey(e,{id:r.did});return this.analyticsService.trackDIDUsage({did:r.did,operation:"sign",duration:performance.now()-n,hsmBacked:!0}),{success:!0,signature:s.signature,publicKey:s.publicKey,did:r.did,timestamp:new Date,hsmBacked:!0}}const i=R.sign(e,t),a=this.didRegistry.get(r.did);return a&&(a.lastUsed=new Date,a.verificationCount++),this.analyticsService.trackDIDUsage({did:r.did,operation:"sign",duration:performance.now()-n,hsmBacked:!1}),{success:!0,signature:i,publicKey:r.publicKey,did:r.did,timestamp:new Date,hsmBacked:!1}}catch(i){return d.logError("DID signing failed:",i),{success:!1,error:i instanceof Error?i.message:"Signing failed",did:r.did,timestamp:new Date}}}static async verifyDIDSignature(e,t,r,n){const i=performance.now();try{const a=R.verify(e,t,r);if(n){const s=this.didRegistry.get(n);s&&s.verificationCount++,this.analyticsService.trackDIDUsage({did:n,operation:"verify",duration:performance.now()-i,success:a})}return{valid:a,did:n,timestamp:new Date,verificationTime:performance.now()-i}}catch(a){return d.logError("DID verification failed:",a),{valid:!1,error:a instanceof Error?a.message:"Verification failed",did:n,timestamp:new Date,verificationTime:performance.now()-i}}}static extractPublicKeyFromDID(e){try{if(!e.startsWith(this.DID_KEY_PREFIX))throw new Error("Invalid DID format");const t=e.substring(this.DID_KEY_PREFIX.length);return _.decode(t).slice(this.ED25519_MULTICODEC_PREFIX.length)}catch(t){return d.logError("Failed to extract public key from DID:",t),null}}static async resolveDID(e){const t=performance.now();try{const r=this.didCache.get(e);if(r)return{success:!0,document:r,cached:!0,resolutionTime:performance.now()-t};if(e.startsWith(this.DID_KEY_PREFIX)){const n=this.extractPublicKeyFromDID(e);if(!n)throw new Error("Invalid DID format");const i=this.createDIDDocument(e,n);return this.didCache.set(e,i),{success:!0,document:i,cached:!1,resolutionTime:performance.now()-t}}return await this.resolveWithUniversalResolver(e)}catch(r){return d.logError("DID resolution failed:",r),{success:!1,error:r instanceof Error?r.message:"Resolution failed",resolutionTime:performance.now()-t}}}static async validateDIDDocument(e){const t=performance.now();try{if(!["@context","id","verificationMethod","authentication","assertionMethod"].every(a=>e.hasOwnProperty(a)&&e[a]!==null))return{valid:!1,errors:["Missing required fields"],validationTime:performance.now()-t};if(!Array.isArray(e["@context"])||!e["@context"].includes("https://www.w3.org/ns/did/v1"))return{valid:!1,errors:["Invalid @context"],validationTime:performance.now()-t};if(!Array.isArray(e.verificationMethod))return{valid:!1,errors:["Invalid verification method"],validationTime:performance.now()-t};const i=[];for(const a of e.verificationMethod)(!a.id||!a.type||!a.controller||!a.publicKeyMultibase)&&i.push(`Invalid verification method: ${a.id||"unknown"}`);return{valid:i.length===0,errors:i.length>0?i:void 0,validationTime:performance.now()-t}}catch(r){return d.logError("DID document validation failed:",r),{valid:!1,errors:[r instanceof Error?r.message:"Validation failed"],validationTime:performance.now()-t}}}static async generateDIDFromSeed(e){const t=performance.now();try{const r=new TextEncoder().encode(e),i=X(r).slice(0,32),a=R.getPublicKey(i),s=this.encodePublicKeyMultibase(a),o=`${this.DID_KEY_PREFIX}${s}`,c=this.createDIDDocument(o,a);return this.analyticsService.trackDIDCreation({did:o,method:"did:key",creationTime:performance.now()-t,hsmBacked:!1,keyType:"Ed25519",seedBased:!0}),{success:!0,did:o,privateKey:i,publicKey:a,document:c,hsmBacked:!1,creationTime:performance.now()-t}}catch(r){return d.logError("Seed-based DID generation failed:",r),{success:!1,error:r instanceof Error?r.message:"Seed generation failed",creationTime:performance.now()-t}}}static async rotateDIDKey(e,t){const r=performance.now();try{const n=R.utils.randomPrivateKey(),i=R.getPublicKey(n),a=this.createDIDDocument(e,i);this.didCache.set(e,a);const s=this.didRegistry.get(e);return s&&(s.keyRotations++,s.lastUsed=new Date),this.analyticsService.trackDIDKeyRotation({did:e,rotationTime:performance.now()-r,newPublicKey:_.encode(i)}),{success:!0,did:e,newPrivateKey:n,newPublicKey:i,newDocument:a,rotationTime:performance.now()-r}}catch(n){return d.logError("DID key rotation failed:",n),{success:!1,error:n instanceof Error?n.message:"Key rotation failed",rotationTime:performance.now()-r}}}static async batchDIDOperations(e){const t=performance.now(),r=[];try{const n=e.map(async s=>{switch(s.type){case"create":return await this.generateDID(s.options);case"resolve":return await this.resolveDID(s.did);case"validate":return await this.validateDIDDocument(s.document);case"rotate":return await this.rotateDIDKey(s.did,s.privateKey);default:return{success:!1,error:"Unknown operation type"}}});(await Promise.allSettled(n)).forEach((s,o)=>{const c=e[o];s.status==="fulfilled"?r.push({operationId:c.id,success:!0,result:s.value}):r.push({operationId:c.id,success:!1,error:s.reason instanceof Error?s.reason.message:"Operation failed"})});const a=r.filter(s=>s.success).length;return{success:!0,operations:r,totalOperations:e.length,successfulOperations:a,processingTime:performance.now()-t}}catch(n){return d.logError("Batch DID operations failed:",n),{success:!1,error:n instanceof Error?n.message:"Batch processing failed",operations:r,totalOperations:e.length,successfulOperations:0,processingTime:performance.now()-t}}}static async getDIDAnalytics(e){if(e){const t=this.didRegistry.get(e);if(!t)throw new Error("DID not found in registry");return{did:e,createdAt:t.created,lastUsed:t.lastUsed,status:t.status,keyRotations:t.keyRotations,verificationCount:t.verificationCount,usageMetrics:await this.analyticsService.getDIDUsageMetrics(e)}}return await this.analyticsService.getAggregateAnalytics()}static async resolveWithUniversalResolver(e){const t=performance.now();try{throw new Error("External DID resolution not implemented")}catch(r){return{success:!1,error:r instanceof Error?r.message:"External resolution failed",resolutionTime:performance.now()-t}}}static clearCache(){this.didCache.clear()}static getCacheStats(){return{size:this.didCache.size,entries:Array.from(this.didCache.keys())}}}class B{static instance;blockchainService;registryCache=new Map;static getInstance(){return B.instance||(B.instance=new B),B.instance}constructor(){this.blockchainService=G}async registerDID(e,t={}){const r=performance.now();try{if(!e.success||!e.did||!e.document)throw new Error("Invalid DID creation result");const n=await this.blockchainService.sendTransaction({to:t.registryAddress||void 0,data:this.encodeDIDRegistration(e.did,e.document),gasLimit:5e5,value:"0",metadata:{operation:"did_registration",didMethod:"did:key",hsmBacked:e.hsmBacked}});if(!n.success)throw new Error(`Blockchain registration failed: ${n.error}`);const i={did:e.did,blockchainTxHash:n.hash,registeredAt:new Date,networkId:this.blockchainService.getCurrentNetwork().id,registryAddress:t.registryAddress||void 0,status:"active",metadata:{hsmBacked:e.hsmBacked,keyType:"Ed25519",creationTime:e.creationTime,...t.metadata}};return this.registryCache.set(e.did,i),this.monitorRegistrationConfirmation(n.hash,e.did),{success:!0,did:e.did,txHash:n.hash,registryRecord:i,registrationTime:performance.now()-r}}catch(n){return d.logError("DID registration failed:",n),{success:!1,error:n instanceof Error?n.message:"Registration failed",registrationTime:performance.now()-r}}}async batchRegisterDIDs(e,t={}){const r=performance.now(),n=[];try{const i=await this.blockchainService.batchTransactions(e.map(a=>({to:t.registryAddress||void 0,data:this.encodeDIDRegistration(a.did,a.document),gasLimit:5e5,value:"0",metadata:{operation:"did_registration",did:a.did,hsmBacked:a.hsmBacked}})));if(!i.success)throw new Error(`Batch registration failed: ${i.error}`);return e.forEach((a,s)=>{if(a.success&&a.did){const o={did:a.did,blockchainTxHash:i.batchHash,registeredAt:new Date,networkId:this.blockchainService.getCurrentNetwork().id,registryAddress:t.registryAddress||void 0,status:"active",metadata:{hsmBacked:a.hsmBacked,keyType:"Ed25519",batchIndex:s}};this.registryCache.set(a.did,o),n.push({success:!0,did:a.did,txHash:i.batchHash,registryRecord:o})}else n.push({success:!1,error:a.error||"DID creation failed"})}),{success:!0,batchTxHash:i.batchHash,results:n,totalRegistrations:e.length,successfulRegistrations:n.filter(a=>a.success).length,processingTime:performance.now()-r}}catch(i){return d.logError("Batch DID registration failed:",i),{success:!1,error:i instanceof Error?i.message:"Batch registration failed",results:n,totalRegistrations:e.length,successfulRegistrations:0,processingTime:performance.now()-r}}}async resolveFromRegistry(e){const t=performance.now();try{const r=this.registryCache.get(e);if(r)return{success:!0,record:r,cached:!0,lookupTime:performance.now()-t};const n=await this.queryBlockchainRegistry(e);return n?(this.registryCache.set(e,n),{success:!0,record:n,cached:!1,lookupTime:performance.now()-t}):{success:!1,error:"DID not found in registry",lookupTime:performance.now()-t}}catch(r){return d.logError("Registry lookup failed:",r),{success:!1,error:r instanceof Error?r.message:"Lookup failed",lookupTime:performance.now()-t}}}async updateDIDStatus(e,t,r){const n=performance.now();try{const i=await this.blockchainService.sendTransaction({to:void 0,data:this.encodeDIDStatusUpdate(e,t,r),gasLimit:3e5,value:"0",metadata:{operation:"did_status_update",did:e,newStatus:t,reason:r}});if(!i.success)throw new Error(`Status update failed: ${i.error}`);const a=this.registryCache.get(e);return a&&(a.status=t,a.metadata={...a.metadata,statusUpdatedAt:new Date,statusUpdateReason:r}),{success:!0,did:e,newStatus:t,txHash:i.hash,updateTime:performance.now()-n}}catch(i){return d.logError("DID status update failed:",i),{success:!1,error:i instanceof Error?i.message:"Status update failed",updateTime:performance.now()-n}}}async getRegistryAnalytics(){const e=Array.from(this.registryCache.values());return{totalRegistrations:e.length,activeRegistrations:e.filter(t=>t.status==="active").length,revokedRegistrations:e.filter(t=>t.status==="revoked").length,suspendedRegistrations:e.filter(t=>t.status==="suspended").length,hsmBackedPercentage:e.filter(t=>t.metadata?.hsmBacked).length/e.length*100,networkDistribution:this.getNetworkDistribution(e),registrationsOverTime:this.getRegistrationsOverTime(e)}}encodeDIDRegistration(e,t){return JSON.stringify({did:e,document:t,timestamp:Date.now()})}encodeDIDStatusUpdate(e,t,r){return JSON.stringify({did:e,status:t,reason:r,timestamp:Date.now()})}async queryBlockchainRegistry(e){return null}async monitorRegistrationConfirmation(e,t){setTimeout(async()=>{const r=await this.blockchainService.getTransactionReceipt(e);if(r.success){const n=this.registryCache.get(t);n&&(n.metadata={...n.metadata,confirmed:!0,blockNumber:r.blockNumber,confirmationTime:new Date})}},5e3)}getNetworkDistribution(e){const t={};return e.forEach(r=>{t[r.networkId]=(t[r.networkId]||0)+1}),t}getRegistrationsOverTime(e){const t=e.reduce((r,n)=>{const i=n.registeredAt.toISOString().split("T")[0];return r[i]=(r[i]||0)+1,r},{});return Object.entries(t).map(([r,n])=>({date:r,count:n}))}}class x{static instance;resolverCache=new Map;resolverEndpoints=new Map;static getInstance(){return x.instance||(x.instance=new x),x.instance}constructor(){this.resolverEndpoints.set("did:key","builtin"),this.resolverEndpoints.set("did:web","https://dev.uniresolver.io/1.0/identifiers/"),this.resolverEndpoints.set("did:ethr","https://dev.uniresolver.io/1.0/identifiers/"),this.resolverEndpoints.set("did:ion","https://dev.uniresolver.io/1.0/identifiers/"),this.resolverEndpoints.set("did:personachain","builtin")}async resolveDID(e,t={}){const r=performance.now();try{if(!t.forceRefresh){const a=this.resolverCache.get(e);if(a)return{...a,cached:!0,resolutionTime:performance.now()-r}}const n=this.extractDIDMethod(e);if(!n)throw new Error("Invalid DID format");const i=await this.resolveByMethod(e,n,t);return i.success&&this.resolverCache.set(e,i),{...i,resolutionTime:performance.now()-r}}catch(n){return d.logError("DID resolution failed:",n),{success:!1,error:n instanceof Error?n.message:"Resolution failed",resolutionTime:performance.now()-r}}}async verifyDIDCrossChain(e,t){const r=performance.now(),n=[];try{const i=t.map(async c=>{const g=await this.verifyDIDOnNetwork(e,c);return{network:c,...g}});(await Promise.allSettled(i)).forEach((c,g)=>{c.status==="fulfilled"?n.push(c.value):n.push({network:t[g],verified:!1,error:c.reason instanceof Error?c.reason.message:"Verification failed"})});const s=n.filter(c=>c.verified).length,o=t.length;return{success:!0,did:e,verifiedNetworks:s,totalNetworks:o,verificationPercentage:s/o*100,results:n,verificationTime:performance.now()-r}}catch(i){return d.logError("Cross-chain verification failed:",i),{success:!1,error:i instanceof Error?i.message:"Cross-chain verification failed",verificationTime:performance.now()-r}}}async batchResolveDIDs(e,t={}){const r=performance.now(),n=[];try{const i=t.concurrencyLimit||10,a=this.chunkArray(e,i);for(const o of a){const c=o.map(f=>this.resolveDID(f,t));(await Promise.allSettled(c)).forEach(f=>{f.status==="fulfilled"?n.push(f.value):n.push({success:!1,error:f.reason instanceof Error?f.reason.message:"Resolution failed"})})}const s=n.filter(o=>o.success).length;return{success:!0,results:n,totalDIDs:e.length,successfulResolutions:s,resolutionPercentage:s/e.length*100,processingTime:performance.now()-r}}catch(i){return d.logError("Batch resolution failed:",i),{success:!1,error:i instanceof Error?i.message:"Batch resolution failed",results:n,totalDIDs:e.length,successfulResolutions:0,processingTime:performance.now()-r}}}async checkDIDPortability(e){const t=performance.now();try{const r=["ethereum","polygon","bsc","personachain"],n=await this.verifyDIDCrossChain(e,r),i=n.verifiedNetworks>1,a=n.results.filter(s=>s.verified).map(s=>s.network);return{success:!0,did:e,isPortable:i,supportedNetworks:a,portabilityScore:n.verificationPercentage,recommendations:this.generatePortabilityRecommendations(e,n),checkTime:performance.now()-t}}catch(r){return d.logError("Portability check failed:",r),{success:!1,error:r instanceof Error?r.message:"Portability check failed",checkTime:performance.now()-t}}}extractDIDMethod(e){const t=e.match(/^did:([^:]+):/);return t?t[1]:null}async resolveByMethod(e,t,r){const n=this.resolverEndpoints.get(`did:${t}`);if(!n)throw new Error(`Unsupported DID method: ${t}`);return n==="builtin"?await this.resolveBuiltinMethod(e,t):await this.resolveExternalMethod(e,n,r)}async resolveBuiltinMethod(e,t){if(t==="key")return await y.resolveDID(e);if(t==="personachain")return await this.resolvePersonaChainDID(e);throw new Error(`Builtin resolver not implemented for method: ${t}`)}async resolveExternalMethod(e,t,r){const n=await fetch(`${t}${e}`,{headers:{Accept:"application/json","Content-Type":"application/json"}});if(!n.ok)throw new Error(`External resolver failed: ${n.status}`);const i=await n.json();return{success:!0,document:i.didDocument,metadata:i.didDocumentMetadata,cached:!1}}async resolvePersonaChainDID(e){throw new Error("PersonaChain resolver not implemented")}async verifyDIDOnNetwork(e,t){try{await G.switchNetwork(t);const n=await B.getInstance().resolveFromRegistry(e);return{verified:n.success,network:t,registryRecord:n.record,error:n.error}}catch(r){return{verified:!1,network:t,error:r instanceof Error?r.message:"Network verification failed"}}}chunkArray(e,t){const r=[];for(let n=0;n<e.length;n+=t)r.push(e.slice(n,n+t));return r}generatePortabilityRecommendations(e,t){const r=[];t.verificationPercentage<50&&r.push("Consider registering DID on additional networks for better portability"),t.verificationPercentage===100&&r.push("Excellent portability - DID verified on all tested networks");const n=t.results.filter(i=>!i.verified).map(i=>i.network);return n.length>0&&r.push(`Consider registering on: ${n.join(", ")}`),r}clearCache(){this.resolverCache.clear()}getResolverStats(){return{cacheSize:this.resolverCache.size,supportedMethods:Array.from(this.resolverEndpoints.keys()),cachedDIDs:Array.from(this.resolverCache.keys())}}}class z{static STORAGE_KEY_PREFIX="personapass_did_";static async storeDID(e,t){try{const r=`${this.STORAGE_KEY_PREFIX}${e}`,n={did:t.did,privateKey:Array.from(t.privateKey),publicKey:Array.from(t.publicKey),document:t.document,createdAt:new Date().toISOString()};localStorage.setItem(r,JSON.stringify(n)),console.log(`[SUCCESS] DID stored successfully with alias: ${e}`)}catch(r){throw d.logError("[ERROR] DID storage failed:",r),new Error(`Failed to store DID: ${r instanceof Error?r.message:"Unknown error"}`)}}static async retrieveDID(e){try{const t=`${this.STORAGE_KEY_PREFIX}${e}`,r=localStorage.getItem(t);if(!r)return null;const n=JSON.parse(r);return{did:n.did,privateKey:new Uint8Array(n.privateKey),publicKey:new Uint8Array(n.publicKey),document:n.document}}catch(t){return d.logError("[ERROR] DID retrieval failed:",t),null}}static async listDIDs(){try{const e=[];for(let t=0;t<localStorage.length;t++){const r=localStorage.key(t);if(r&&r.startsWith(this.STORAGE_KEY_PREFIX)){const n=r.substring(this.STORAGE_KEY_PREFIX.length);e.push(n)}}return e}catch(e){return d.logError("[ERROR] DID listing failed:",e),[]}}static async deleteDID(e){try{const t=`${this.STORAGE_KEY_PREFIX}${e}`;localStorage.removeItem(t),console.log(`[SUCCESS] DID deleted successfully: ${e}`)}catch(t){throw d.logError("[ERROR] DID deletion failed:",t),new Error(`Failed to delete DID: ${t instanceof Error?t.message:"Unknown error"}`)}}}class ne{async generateDID(e){return await y.generateDID(e)}async signWithDID(e,t,r){return await y.signWithDID(e,t,r)}async verifyDIDSignature(e,t,r,n){return await y.verifyDIDSignature(e,t,r,n)}extractPublicKeyFromDID(e){return y.extractPublicKeyFromDID(e)}async resolveDID(e){return await y.resolveDID(e)}async validateDIDDocument(e){return await y.validateDIDDocument(e)}async generateDIDFromSeed(e){return await y.generateDIDFromSeed(e)}async rotateDIDKey(e,t){return await y.rotateDIDKey(e,t)}async batchDIDOperations(e){return await y.batchDIDOperations(e)}async getDIDAnalytics(e){return await y.getDIDAnalytics(e)}clearCache(){y.clearCache()}getCacheStats(){return y.getCacheStats()}}const ie=new ne,ae=B.getInstance(),se=x.getInstance(),oe=new z,he=Object.freeze(Object.defineProperty({__proto__:null,DIDRegistryService:B,DIDResolverService:x,DIDService:y,DIDStorageService:z,didRegistryService:ae,didResolverService:se,didService:ie,didStorageService:oe},Symbol.toStringTag,{value:"Module"}));export{y as D,he as a,H as b,ie as d,U as w};
